var tipuesearch = {"pages": [{'title': '簡介', 'text': '零組件繪圖系統 \n 這裡是國立虎尾科技大學機械設計工程系電腦輔助設計實習課程教材, 所使用的機械零組件設計繪圖, 以  Onshape ,  Fusion 360  與  Solvespace  為主. PTC Creo, SolidWorks 與 Inventor 為輔. \n 電路模擬 \n Arduino 電路與電子系統模擬, 採用  TinkerCAD . \n 可攜程式工具 \n 電腦輔助設計過程所牽涉的程式編寫與運算, 採支援 Python, ANSI C 與 Lua 程式解譯的可攜初階系統,  p37.7z , (下載 240 MB, 解壓縮後 1GB), 以及額外增加 C++ 支援的進階系統,\xa0 Qt 可攜系統 .7z \xa0(下載 8GB, 解壓縮後 21 GB). \n p37_adv.7z  (下載 5GB, 解壓縮後 15 GB) \n 課程倉儲:\xa0 https://github.com/mdecourse/cadp2018 \xa0 \n 本課程名稱為 電腦輔助設計實習  , 承接 計算機程式 與網際內容管理課程, 並為協同產品設計實習課程的先修課. \n 課程英文名稱 \n 電腦輔助設計實習:\xa0 Introduction to Computer-aided Design and Practice \n 計算機程式: Introduction to Computer Programming\xa0 \n 網際內容管理: Web-based Content Management System \n 協同產品設計實習: Collaborative Product Design and Practice \n 課程規劃 \n 2018 Fall 電腦輔助設計實習課程規劃心智圖 \xa0(under scrum1 At mde) \n Intro_cad.pdf \n kinematics_of_machines.pdf \n robot_kinematics_and_dynamics.pdf', 'tags': '', 'url': '簡介.html'}, {'title': 'Curves and Surfaces', 'text': 'Introduction to curves and surfaces.pdf \n Introduction to curves.pdf \n mit intro to CAD.pdf \n Open-source, cross-platform NURBS:\xa0 https://github.com/pboyer/verb \xa0 \n http://verbnurbs.com/ \xa0 \n https://mattdesl.svbtle.com/drawing-lines-is-hard \xa0 \n https://pomax.github.io/bezierinfo/ \xa0 \n https://github.com/Ciechan/Drawing-Bezier-Curves-JS \xa0 \n http://ciechanowski.me/blog/2014/02/18/drawing-bezier-curves/ \xa0 \n', 'tags': '', 'url': 'Curves and Surfaces.html'}, {'title': '最佳化設計', 'text': 'Mechanical Design Optimization Using Advanced Optimization Techniques \n https://link.springer.com/book/10.1007/978-1-4471-2748-2 \xa0 \n Optimization Methods for Engineering Design \n http://apmonitor.com/me575/uploads/Main/optimization_book.pdf \xa0\xa0or  local \n https://github.com/williamhunter/topy \xa0 \n http://www.analyzemath.com/calculus.html#Calculus_Problems \n 以  Differential Evolution  algorithm 解題: \n 以總面積 80 cm^2 的鐵皮所能焊出最大容量的方形容器: \n // 必須在演算過程中, 設法限制各變數的上下限!\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <memory.h>\n#include <time.h>\n \n// 最大族群數, NP\n#define MAXPOP  5000\n// 最大向量維度, D\n#define MAXDIM  35\n// MAXIMAPROBLEM =1 最大化 0 最小化\n#define MAXIMAPROBLEM 1\n// 最大化時 PENALITY 必須為負值, 否則為正值\n#define PENALITY -1000\n/*\n#define MAXIMAPROBLEM 0\n#define PENALITY 1000\n*/\n \n/*------Constants for rnd_uni()--------------------------------------------*/\n \n#define IM1 2147483563\n#define IM2 2147483399\n#define AM (1.0/IM1)\n#define IMM1 (IM1-1)\n#define IA1 40014\n#define IA2 40692\n#define IQ1 53668\n#define IQ2 52774\n#define IR1 12211\n#define IR2 3791\n#define NTAB 32\n#define NDIV (1+IMM1/NTAB)\n#define EPS 1.2e-7\n#define RNMX (1.0-EPS)\n \n/*------------------------Globals---------------------------------------*/\n \nlong  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */\ndouble c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];\ndouble (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];\n \n/*---------Function declarations----------------------------------------*/\n \nvoid  assignd(int D, double a[], double b[]);\ndouble rnd_uni(long *idum);    /* uniform pseudo random number generator */\ndouble extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */\n \n/*---------Function definitions-----------------------------------------*/\n// 指定向量 b 為 a\nvoid  assignd(int D, double a[], double b[])\n{\n   int j;\n   for (j=0; j<D; j++)\n   {\n      a[j] = b[j];\n   }\n}\n \n// 產生 0 ~ 1 間的亂數\ndouble rnd_uni(long *idum)\n{\n  long j;\n  long k;\n  static long idum2=123456789;\n  static long iy=0;\n  static long iv[NTAB];\n  double temp;\n \n  if (*idum <= 0)\n  {\n    if (-(*idum) < 1) *idum=1;\n    else *idum = -(*idum);\n    idum2=(*idum);\n    for (j=NTAB+7;j>=0;j--)\n    {\n      k=(*idum)/IQ1;\n      *idum=IA1*(*idum-k*IQ1)-k*IR1;\n      if (*idum < 0) *idum += IM1;\n      if (j < NTAB) iv[j] = *idum;\n    }\n    iy=iv[0];\n  }\n  k=(*idum)/IQ1;\n  *idum=IA1*(*idum-k*IQ1)-k*IR1;\n  if (*idum < 0) *idum += IM1;\n  k=idum2/IQ2;\n  idum2=IA2*(idum2-k*IQ2)-k*IR2;\n  if (idum2 < 0) idum2 += IM2;\n  j=iy/NDIV;\n  iy=iv[j]-idum2;\n  iv[j] = *idum;\n  if (iy < 1) iy += IMM1;\n  if ((temp=AM*iy) > RNMX) return RNMX;\n  else return temp;\n \n}/*------End of rnd_uni()--------------------------*/\n \n// 將上下限轉為全域變數\ndouble inibound_h;      /* upper parameter bound              */\ndouble inibound_l;      /* lower parameter bound              */\n// 與機構合成相關的全域變數\n// 宣告一個座標結構\nstruct Coord {\n    double x;\n    double y;\n  // 這裡保留 double z;\n};\n \nmain(int argc, char *argv[])\n{\n   char  chr;             /* y/n choice variable                */\n   char  *strat[] =       /* strategy-indicator                 */\n   {\n            "",\n            "DE/best/1/exp",\n            "DE/rand/1/exp",\n            "DE/rand-to-best/1/exp",\n            "DE/best/2/exp",\n            "DE/rand/2/exp",\n            "DE/best/1/bin",\n            "DE/rand/1/bin",\n            "DE/rand-to-best/1/bin",\n            "DE/best/2/bin",\n            "DE/rand/2/bin"\n   };\n \n   int   i, j, L, n;      /* counting variables                 */\n   int   r1, r2, r3, r4;  /* placeholders for random indexes    */\n   int   r5;              /* placeholders for random indexes    */\n   int   D;               /* Dimension of parameter vector      */\n   int   NP;              /* number of population members       */\n   int   imin;            /* index to member with lowest energy */\n   int   refresh;         /* refresh rate of screen output      */\n   int   strategy;        /* choice parameter for screen output */\n   int   gen, genmax, seed;   \n \n   long  nfeval;          /* number of function evaluations     */\n \n   double trial_cost;      /* buffer variable                    */\n   // 將上下限轉為全域變數, 可能要根據各變數加以設定\n   //double inibound_h;      /* upper parameter bound              */\n   //double inibound_l;      /* lower parameter bound              */\n   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */\n   double cost[MAXPOP];    /* obj. funct. values                 */\n   double cvar;            /* computes the cost variance         */\n   double cmean;           /* mean cost                          */\n   double F,CR;            /* control variables of DE            */\n   double cmin;            /* help variables                     */\n \n   FILE  *fpin_ptr;\n   FILE  *fpout_ptr;\n \n// 計算執行過程所需時間起點, 需要導入 time.h\n  clock_t start = clock();\n \n/*------Initializations----------------------------*/\n \n// 將結果寫入 out.dat\n fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */\n// 目前已經採用 strategy 3 可以得到最佳結果\n  strategy = 3;\n  genmax = 2000;\n  refresh = 100;\n  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值\n  D = 2;\n  NP = 200;\n  inibound_h = 50.;\n  inibound_l = 0.;\n/*得到最佳解\n  F = 0.85;\nCR 必須介於 0 to 1. 之間\n  CR = 1.;\n*/\n  F = 0.85;\n  CR = 1.;\n  seed = 3;\n \n //fclose(fpin_ptr);\n \n/*-----Checking input variables for proper range----------------------------*/\n \n  if (D > MAXDIM)\n  {\n     printf("\\nError! D=%d > MAXDIM=%d\\n",D,MAXDIM);\n     exit(1);\n  }\n  if (D <= 0)\n  {\n     printf("\\nError! D=%d, should be > 0\\n",D);\n     exit(1);\n  }\n  if (NP > MAXPOP)\n  {\n     printf("\\nError! NP=%d > MAXPOP=%d\\n",NP,MAXPOP);\n     exit(1);\n  }\n  if (NP <= 0)\n  {\n     printf("\\nError! NP=%d, should be > 0\\n",NP);\n     exit(1);\n  }\n  if ((CR < 0) || (CR > 1.0))\n  {\n     printf("\\nError! CR=%f, should be ex [0,1]\\n",CR);\n     exit(1);\n  }\n  if (seed <= 0)\n  {\n     printf("\\nError! seed=%d, should be > 0\\n",seed);\n     exit(1);\n  }\n  if (refresh <= 0)\n  {\n     printf("\\nError! refresh=%d, should be > 0\\n",refresh);\n     exit(1);\n  }\n  if (genmax <= 0)\n  {\n     printf("\\nError! genmax=%d, should be > 0\\n",genmax);\n     exit(1);\n  }\n  if ((strategy < 0) || (strategy > 10))\n  {\n     printf("\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n",strategy);\n     exit(1);\n  }\n  if (inibound_h < inibound_l)\n  {\n     printf("\\nError! inibound_h=%f < inibound_l=%f\\n",inibound_h, inibound_l);\n     exit(1);\n  }\n \n/*-----Initialize random number generator-----------------------------*/\n \n rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */\n nfeval       =  0;  /* reset number of function evaluations */\n \n/*------Initialization------------------------------------------------*/\n/*------Right now this part is kept fairly simple and just generates--*/\n/*------random numbers in the range [-initfac, +initfac]. You might---*/\n/*------want to extend the init part such that you can initialize-----*/\n/*------each parameter separately.------------------------------------*/\n \n   for (i=0; i<NP; i++)\n   {\n      for (j=0; j<D; j++) /* spread initial population members */\n      {\n        c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l);\n      }\n      cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */\n   }\n   cmin = cost[0];\n   imin = 0;\n   for (i=1; i<NP; i++)\n   {\n     if(MAXIMAPROBLEM == 1)\n     {\n       // 改為最大化\n        if (cost[i]>cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n      else\n      {\n        // 最小化問題\n        if (cost[i]<cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n   }\n \n   assignd(D,best,c[imin]);            /* save best member ever          */\n   assignd(D,bestit,c[imin]);          /* save best member of generation */\n \n   pold = &c; /* old population (generation G)   */\n   pnew = &d; /* new population (generation G+1) */\n \n/*=======================================================================*/\n/*=========Iteration loop================================================*/\n/*=======================================================================*/\n \n   gen = 0;                          /* generation counter reset */\n   while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */\n   {                                            /* is accepted by compiler    */\n      gen++;\n      imin = 0;\n \n      for (i=0; i<NP; i++)         /* Start of loop through ensemble  */\n      {\n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 2 !!!     */\n       r1 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while(r1==i);            \n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 3 !!!     */\n       r2 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r2==i) || (r2==r1));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 4 !!!     */\n       r3 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r3==i) || (r3==r1) || (r3==r2));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 5 !!!     */\n       r4 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 6 !!!     */\n       r5 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));\n \n/*=======EXPONENTIAL CROSSOVER============================================================*/\n \n/*-------DE/best/1/exp--------------------------------------------------------------------*/\n/*-------Our oldest strategy but still not bad. However, we have found several------------*/\n/*-------optimization problems where misconvergence occurs.-------------------------------*/\n     if (strategy == 1) /* strategy DE0 (not in our paper) */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/1/exp-------------------------------------------------------------------*/\n/*-------This is one of my favourite strategies. It works especially well when the-------*/\n/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/\n/*-------as a first guess.---------------------------------------------------------------*/\n     else if (strategy == 2) /* strategy DE1 in the techreport */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/\n/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/\n/*-------If you get misconvergence try to increase NP. If this doesn\'t help you----------*/\n/*-------should play around with all three control variables.----------------------------*/\n     else if (strategy == 3) /* similiar to DE2 but generally better */\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                       \n         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/\n     else if (strategy == 4)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/\n     else if (strategy == 5)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n \n/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/\n \n/*-------DE/best/1/bin--------------------------------------------------------------------*/\n     else if (strategy == 6) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/1/bin-------------------------------------------------------------------*/\n     else if (strategy == 7) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/\n     else if (strategy == 8) \n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/best/2/bin--------------------------------------------------------------------*/\n     else if (strategy == 9)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/2/bin--------------------------------------------------------------------*/\n     else\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n \n \n/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/\n \n     trial_cost = evaluate(D,tmp,&nfeval);  /* Evaluate new vector in tmp[] */\n   if(MAXIMAPROBLEM == 1)\n   {\n    // 改為最大化\n       if (trial_cost >= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost>cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n    else\n    {\n          // 最小化問題\n       if (trial_cost <= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost<cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n \n      }   /* End mutation loop through pop. */\n \n      assignd(D,bestit,best);  /* Save best population member of current iteration */\n \n      /* swap population arrays. New generation becomes old one */\n \n      pswap = pold;\n      pold  = pnew;\n      pnew  = pswap;\n \n/*----Compute the energy variance (just for monitoring purposes)-----------*/\n \n      cmean = 0.;          /* compute the mean value first */\n      for (j=0; j<NP; j++)\n      {\n         cmean += cost[j];\n      }\n      cmean = cmean/NP;\n \n      cvar = 0.;           /* now the variance              */\n      for (j=0; j<NP; j++)\n      {\n         cvar += (cost[j] - cmean)*(cost[j] - cmean);\n      }\n      cvar = cvar/(NP-1);\n \n \n/*----Output part----------------------------------------------------------*/\n \n      if (gen%refresh==1)   /* display after every refresh generations */\n      { /* ABORT works only if conio.h is accepted by your compiler */\n    printf("\\n\\n                         PRESS ANY KEY TO ABORT"); \n    printf("\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n",cmin);\n \n    for (j=0;j<D;j++)\n    {\n      printf("\\n best[%d]=%-15.10g",j,best[j]);\n    }\n    printf("\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n    printf("\\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\\n",\n               NP,F,CR,cvar);\n      }\n \n      fprintf(fpout_ptr,"%ld   %-15.10g\\n",nfeval,cmin);\n   }\n/*=======================================================================*/\n/*=========End of iteration loop=========================================*/\n/*=======================================================================*/\n \n/*-------Final output in file-------------------------------------------*/\n \n \n   fprintf(fpout_ptr,"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n",cmin);\n \n   for (j=0;j<D;j++)\n   {\n     fprintf(fpout_ptr,"\\n best[%d]=%-15.10g",j,best[j]);\n   }\n   fprintf(fpout_ptr,"\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n   fprintf(fpout_ptr,"\\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\\n",\n           NP,F,CR,cvar); \n \n  fclose(fpout_ptr);\n \n  /* Code you want timed here */\n  printf("Time elapsed: %f\\n", ((double)clock() - start) / CLOCKS_PER_SEC);\n   return(0);\n}\n \n/*-----------End of main()------------------------------------------*/\n \n// 適應函式 fittness function (cost function)\ndouble evaluate(int D, double tmp[], long *nfeval)\n{\n   double result=0, surface = 80.0, z, volume, penality;\n   (*nfeval)++;\n   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));\n   volume = tmp[0]*tmp[1]*z;\n \n  if(volume <= 0){\n    return PENALITY;\n  }\n// 只限制長度與寬度必須大於 0\n  if(tmp[0] <= inibound_l){\n    return PENALITY;\n  }\n \n  if(tmp[1] <= inibound_l){\n    return PENALITY;\n  }\n/*\n  if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){\n    return PENALITY;\n  }\n \n  if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){\n    return PENALITY;\n  }\n  */\n  // volume must >0 and max volume\n  // 目前為最小化問題\n   //return 1+1/(volume*volume);\n  return volume;\n}\n  \n Python  Differential Evolution  algorithm: \n import random\n\nclass Chromosome(object):\n\n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    def __init__(self, n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = [0] * n\n        # the fitness value\n        self.f = 0\n\n    def assign(self, obj):\n        """\n        Chromosome obj\n\n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v = obj.v[:]\n        self.f = obj.f\n\n\nclass DiffertialEvolution(object):\n\n    def __init__(self,Func, pType, strategy, D, NP, F, CR, lower, upper, maxGen, report):\n        # if pType = 1 it is maximization  otherwise is minimization problem\n        self.pType = pType\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # lower bound array\n        self.lb = lower[:]\n        # upper bound array\n        self.ub = upper[:]\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n\n        # generation pool, depend on population size\n        self.pop = [Chromosome(D) for i in range(NP)]\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n\n    def checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n\n    def init(self):\n        """\n        init population\n        """\n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + random.random()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n\n    def evalute(self, p):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(p.v)\n\n    def findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        if self.pType == 1:\n            return max(self.pop, key=lambda chrom:chrom.f)\n        else:\n            return min(self.pop, key=lambda chrom:chrom.f)\n\n    def generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(random.random() * self.NP)\n            if not (self.r1 == i):\n                break\n\n        while True:\n            self.r2 = int(random.random() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n\n        while True:\n            self.r3 = int(random.random() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n\n        while True:\n            self.r4 = int(random.random() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n\n        while True:\n            self.r5 = int(random.random() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n\n    def recombination(self, i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        tmp = Chromosome(self.D)\n\n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n\n            n = int(random.random() * self.D)\n\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n\n                n = (n + 1) % self.D\n\n        else:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n\n    def report(self):\n        """\n        report current generation status\n        """\n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at", self.gen, "generations")\n        else:\n            print("DiffertialEvolution results after", self.gen, "generations")\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v, start=1):\n            print("Var", i, ":", v)\n\n    def overbound(self, member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n\n    def run(self):\n        """\n        run the algorithm...\n        """\n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n\n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then ignore\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is larger or smaller)\n                # pType is 1, the problem is maximization type\n                if self.pType == 1:\n                    if tmp.f >= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f > self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n                else:\n                    if tmp.f <= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f < self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report()\n\n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n\n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n  \n    if(volume <= 0):\n        return penality\n\n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n\n    if(designVariablel[1] <= 0):\n        return penality\n    return volume\n#volume = DiffertialEvolution((self,Func, max, strategy, D, NP, F, CR, lower, upper, maxGen, report)\nvolume = DiffertialEvolution(evaluate, 1, 3, 2, 100, 0.6, 0.85, [0, 0], [50, 50], 100, 10)\nvolume.run()\n \n 將上述 Python 程式轉為 Cython 格式: \n #import random\nfrom cpython cimport bool\n#from array import array\nimport numpy as np\ncimport numpy as np\nfrom libc.stdlib cimport rand, RAND_MAX, srand\nfrom libc.time cimport time\n\n# make true it is random everytime\nsrand(time(NULL))\n\ncdef double randV():\n    return rand()*1.0 / RAND_MAX\n\ncdef class Chromosome(object):\n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    cdef public int n\n    cdef public double f\n    cdef public np.ndarray v\n\n    def __cinit__(self, int n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = np.zeros(n)\n        # the fitness value\n        self.f = 0\n\n    def assign(self, Chromosome obj):\n        """\n        Chromosome obj\n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v[:] = obj.v\n        self.f = obj.f\n\n\ncdef class DiffertialEvolution(object):\n\n    cdef:\n        int strategy, D, NP, maxGen, rpt, gen, r1, r2, r3, r4, r5\n        double F, CR\n        np.ndarray lb, ub, pop\n        object f\n        Chromosome lastgenbest, currentbest\n\n    def __cinit__(self, object Func, int strategy, int D, int NP, double F, double CR, object lower, object upper, int maxGen, int report):\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # low bound\n        self.lb = np.array(lower[:])\n        # up bound\n        self.ub = np.array(upper[:])\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n\n        # generation pool, depend on population size\n        #self.pop = [Chromosome(self.D) for i in range(self.NP)]\n        self.pop = np.ndarray((NP,),dtype=np.object)\n        for i in range(NP):\n            self.pop[i] = Chromosome(self.D)\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n\n    cdef void checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n\n    cdef void init(self):\n        """\n        init population\n        """\n        cdef int i, j\n\n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + randV()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n\n    cdef double evalute(self, Chromosome member):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(member.v)\n\n    cdef Chromosome findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        return min(self.pop, key=lambda chrom:chrom.f)\n\n    cdef void generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(randV() * self.NP)\n            if not (self.r1 == i):\n                break\n\n        while True:\n            self.r2 = int(randV() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n\n        while True:\n            self.r3 = int(randV() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n\n        while True:\n            self.r4 = int(randV() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n\n        while True:\n            self.r5 = int(randV() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n\n    cdef Chromosome recombination(self, int i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        cdef Chromosome tmp\n        cdef int n, L\n\n        tmp = Chromosome(self.D)\n\n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n\n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n\n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n\n        else:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n\n    cdef void report(self):\n        """\n        report current generation status\n        """\n        cdef int i\n        cdef double v\n\n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at %d generations"%(self.gen,))\n        else:\n            print("DiffertialEvolution results after %d generations"%(self.gen,))\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v.flat, start=1):\n            print("Var %d : %.4f"%(i, v))\n\n    cdef bool overbound(self, Chromosome member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        cdef int i\n\n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n\n    cdef void run(self):\n        """\n        run the algorithm...\n        """\n        cdef Chromosome tmp\n        cdef int i\n\n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n\n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then abandon it\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is smaller)\n                if tmp.f <= self.pop[i].f:\n                    # copy the temporary one to origin member\n                    self.pop[i].assign(tmp)\n                    # check the temporary one is better than the currentbest\n                    if tmp.f < self.currentbest.f:\n                        # copy the temporary one to currentbest\n                        self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report() \n 使用 Real-coded Genetic algorithm 解題: \n import time\nimport math\n\n\nclass Chromosome(object):\n\n    def __init__(self, n=None):\n        self.np = n if n > 0 else 2\n        self.f = 0.0\n        self.v = [0.0] * n\n\n    def cp(self, obj):\n        """\n        copy all atribute from another chromsome object\n        """\n        self.np = obj.np\n        self.f = obj.f\n        self.v = obj.v[:]\n\n    def get_v(self, i):\n        return self.v[i]\n\n    def is_self(self, obj):\n        """\n        check the object is self?\n        """\n        return obj is self\n\n    def assign(self, obj):\n        if not self.is_self(obj):\n            self.cp(obj)\n\n\nclass Genetic(object):\n\n    def __init__(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\n        """\n        init(function func)\n        """\n        self.func=func\n        self.pType = pType\n        self.nParm=nParm\n        self.nPop=nPop\n        self.pCross=pCross\n        self.pMute=pMute\n        self.pWin=pWin\n        self.bDelta=bDelta\n\n        self.chrom = [Chromosome(nParm) for i in range(nPop)]\n        self.newChrom = [Chromosome(nParm) for i in range(nPop)]\n        self.babyChrom = [Chromosome(nParm) for i in range(3)]\n        self.chromElite = [Chromosome(nParm)]\n        self.chromBest = [Chromosome(nParm)]\n        self.maxLimit = upper[:]\n        self.minLimit = lower[:]\n\n        self.maxGen = None\n        self.gen = None\n\n        self.seed = 0.0\n        self.iseed = 470211272.0\n        self.mask = 2147483647\n\n    def check(self, i, v):\n        """\n        If a variable is out of bound,\n        replace it with a random value\n        """\n        if (v > self.maxLimit[i]) or (v < self.minLimit[i]):\n            return self.randVal(self.minLimit[i], self.maxLimit[i])\n        return v\n\n    def crossOver(self):\n        for i in range(0, self.nPop-1, 2):\n            # crossover\n            if(self.rnd() < self.pCross):\n                for s in range(self.nParm):\n                    # first baby, half father half mother\n                    self.babyChrom[0].v[s] = 0.5 * self.chrom[i].v[s] + 0.5*self.chrom[i+1].v[s];\n                    # second baby, three quaters of fater and quater of mother\n                    self.babyChrom[1].v[s] = self.check(s, 1.5 * self.chrom[i].v[s] - 0.5*self.chrom[i+1].v[s])\n                    # third baby, quater of fater and three quaters of mother\n                    self.babyChrom[2].v[s] = self.check(s,-0.5 * self.chrom[i].v[s] + 1.5*self.chrom[i+1].v[s]);\n\n                for j in range(3):\n                    self.babyChrom[j].f = self.func(self.babyChrom[j].v)\n                # maximization\n                if self.pType == 1:\n                    \n                    if self.babyChrom[1].f > self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n\n                    if self.babyChrom[2].f > self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n\n                    if self.babyChrom[2].f > self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n\n                else:\n                    \n                    if self.babyChrom[1].f < self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n\n                    if self.babyChrom[2].f < self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n\n                    if self.babyChrom[2].f < self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n\n                # replace first two baby to parent, another one will be\n                self.chrom[i].assign(self.babyChrom[0])\n                self.chrom[i+1].assign(self.babyChrom[1])\n\n    def delta(self, y):\n        r = float(self.gen) / self.maxGen;\n        return y*self.rnd()*math.pow(1.0-r, self.bDelta)\n\n    def fitness(self):\n        for j in range(self.nPop):\n            self.chrom[j].f = self.func(self.chrom[j].v)\n\n        self.chromBest[0].assign(self.chrom[0])\n\n        for j in range(self.nPop):\n            if self.pType == 1:\n                if(self.chrom[j].f > self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n            else:\n                if(self.chrom[j].f < self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n        if self.pType == 1:\n            if(self.chromBest[0].f > self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n        else:\n            if(self.chromBest[0].f < self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n\n    def initialPop(self):\n        for j in range(self.nPop):\n            for i in range(self.nParm):\n                self.chrom[j].v[i] = self.randVal(self.minLimit[i], self.maxLimit[i])\n\n    def mutate(self):\n        for i in range(self.nPop):\n            if self.rnd() < self.pMute:\n                s = self.random(self.nParm)\n                if (self.random(2) == 0):\n                    self.chrom[i].v[s] += self.delta(self.maxLimit[s]-self.chrom[i].v[s])\n                else:\n                    self.chrom[i].v[s] -= self.delta(self.chrom[i].v[s]-self.minLimit[s])\n\n    def report(self):\n        if self.gen == 0:\n            print("Genetik results - Initial population")\n        elif self.gen == self.maxGen:\n            print("Final Genetik results at", self.gen, "generations")\n        else:\n            print("Genetik results after", self.gen, "generations")\n\n        print("Function : %.6f" % (self.chromElite[0].f))\n        for i, p in enumerate(self.chromElite[0].v):\n            print("Var", i+1, ":", p)\n\n    def select(self):\n        """\n        roulette wheel selection\n        """\n        for i in range(self.nPop):\n            j = self.random(self.nPop)\n            k = self.random(self.nPop)\n            self.newChrom[i].assign(self.chrom[j])\n            if self.pType == 1:\n                if(self.chrom[k].f > self.chrom[j].f) and (self.rnd() > self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n            else:\n                if(self.chrom[k].f < self.chrom[j].f) and (self.rnd() < self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n        # in this stage, newChrom is select finish\n        # now replace origin chrom\n        for i in range(self.nPop):\n            self.chrom[i].assign(self.newChrom[i])\n\n        # select random one chrom to be best chrom, make best chrom still exist\n        j = self.random(self.nPop);\n        self.chrom[j].assign(self.chromElite[0])\n\n    def run(self, mxg, rp):\n        """\n        // **** Init and run GA for maxGen times\n        // **** mxg : maximum generation\n        // **** rp  : report cycle, 0 for final report or\n        // ****       report each mxg modulo rp\n        """\n        self.maxGen = mxg\n        self.rpt = rp\n\n        self.randomize()\n        self.initialPop()\n        self.chrom[0].f = self.func(self.chrom[0].v)\n        self.chromElite[0].assign(self.chrom[0])\n\n        self.gen = 0\n        self.fitness()\n        self.report()\n\n        for self.gen in range(1, self.maxGen + 1):\n            self.select()\n            self.crossOver()\n            self.mutate()\n            self.fitness()\n            if rp != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        self.report()\n\n    def newSeed(self):\n        if(self.seed == 0.0):\n            self.seed=self.iseed\n        else:\n            self.seed *= 16807.0\n            self.seed = math.fmod(self.seed, self.mask)\n\n    def rnd(self):\n        self.newSeed()\n        return self.seed/self.mask\n\n    def randomize(self):\n        self.seed = time.time()\n\n    def random(self, k):\n        return int(self.rnd()*k)\n\n    def randVal(self, low, high):\n        number_types = (int, float)\n        if isinstance(low, number_types) and isinstance(high, number_types):\n            return self.rnd()*(high-low)+low\n        raise ValueError\n        \n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n\n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n  \n    if(volume <= 0):\n        return penality\n\n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n\n    if(designVariablel[1] <= 0):\n        return penality\n    #return 1+1/(volume*volume)\n    return volume\n\n#volume = Genetic(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\nvolume = Genetic(evaluate, 1, 2, 1000, 0.95, 0.05, 0.95, 5, [0, 0], [50, 50])\nvolume.run(1000, 50)\n \n \n', 'tags': '', 'url': '最佳化設計.html'}, {'title': '雲端 CAD', 'text': 'Dec. 26 2015 \n Onshape \n 屬於二十一世紀的電腦輔助機械設計軟體: \xa0 http://www.onshape.com \n 西元 2000 年, 當時的 PTC 公司在著名的 Pro/Engineer 套件中加入 Pro/Web.Link, 當時的 Javascript 技術在 Java 強力橫掃程式界的時候, 還是得透過呼叫 Java 程式庫, 才能夠運行, 但是能夠在嵌入式 Internet Explorer 與 Firefox 瀏覽器中運行的半調子 Engineer to Engineer 二次開發技術, 仍然讓人眼睛為之一亮. \n 十幾年過去, 採用 Javascript 技術的 Pro/Web.Link 仍然停留在原地, 沒給隨後改名為 Creo Parametric 的參數化模組, 帶來令人振奮的應用, 但是 Javascript 技術自從 2009 年 node.js 發表以來, 就不斷在全球資訊網的前後端環境嚴密整合下, 持續發光發熱, 加上 HTML5 (2010)、WebGL (2009) 與 Git (2005) 技術的推波助瀾, 終於讓 Onshape: \xa0 http://www.onshape.com \xa0 團隊決定自 2012 年開始, 利用這些相關技術 (結合 Javascript V8 與 NoSQL) 打造一套全瀏覽器的雲端電腦輔助機械設計軟體. \n Onshpae 的推出, 終於讓二十一世紀的機械設計工程師感受到平版與手機時代的到來, 面對全球無縫整合的產品開發流程, 任何人都可以隨時隨地在有網路連線的地方, 用任何裝置參與協同. \n Onshape 的可貴, 不僅解決協同產品開發團隊間, 軟體版次分歧與維護的問題, 而且徹底改變過去產品生命週期管理上, MCAD (Mechanical Computer Aided Design) 軟體套件無法全雲端運作, 所帶來的簽出入時間差異困擾, 讓協同團隊人員, 能夠即時線上協同, 關注同一份設計資料 ,而且整個團隊, 在特定的產品設計專案上, 每個零件與組立圖, 在不同的工作屬性下, 保證只有一份資料. \n 在此同時, Onshape 團隊也意識到全球自造時代 (Self-manufacturing Era) 將會是二十一世紀最重要的產品設計開發模式之一, 因此套件公開推出時, 允許使用者透過免費方案, 將設計內容公開者, 就可以擁有 5GB 的容量空間, 相信此舉會讓過去數以百萬計的標準零件庫迅速納入旗下, 成為全球各方人員搭配組合新產品的重要來源之一. \n 尤有甚者, 全雲端全瀏覽器的 MCAD, 將會帶動隨後全球各類 CAX 應用的虛實整合與平行分散運算, 讓網路上閒置的運算資源降到最低. \n 總而言之, Onshape 的推出, 讓沉悶已久的電腦輔助機械設計界, 重新看到新的契機, 全球協同產品開發不再只是口號, 相信過去幾十年來作威作福的半調子 MCAD & PLM 套件開發者與代理商, 可以深刻記取教訓, 因為真正屬於二十一世紀的電腦輔助機械設計軟體, 已經來了. \n 機器人定義 \n Word robot was coined by a Czech novelist Karel Capek in a 1920 play titled Rassum\'s Universal Robots (RUR), Robot in Czech is a word for worker or servant \n Definition of robot (可程式化之多功能機械稱為機器人): \n 1) Any machine made by by one of our members: Robot Institute of America \n 2) A robot is a reprogrammable, multifunctional manipulator designed to move material, parts, tools or specialized devices through variable programmed motions for the performance of a variety of tasks: Robot Institute of America, 1979 \n 機電資整合課程教育目標 \n Infomechatronics  Course Objectives ( infomechatronics.pdf ) \n \n To produce an engineering graduate with broad knowledge and skills across the three engineering disciplines of Information Technology, Electrical & Electronic and Mechanical & Manufacturing Engineering who meet the needs of industry with respect to the design, fabrication and service of computer controlled industrial machinery and consumer products. \n To provide a broad-based academic training program aimed at producing future industry managers who can be effective in research and technology whilst leading industry in an innovative, efficient and socially responsible way. \n To provide, prior to entry to the work force, a course of study in engineering science and technology with adequate awareness of the importance of a multi-disciplinary approach to the optimal design and fabrication of computer controlled machinery. \n To develop good communication, leadership, managerial, and life long learning skills. \n To develop in graduates a high degree of competence and confidence within their chosen areas of study that will facilitate their ready acceptance into work force in commerce, industry & government. \n To develop in graduates a sound knowledge and understanding of the fundamentals of their discipline so that they can adapt to scientific, technological and social changes. \n To develop the capability for critical thinking and analysis to apply the knowledge gained from their course of study to the solution of real life problems \n To instill a sensitivity to and understanding of culture and gender related issues as they relate to professional and ethical practices \n \n  暫時不用\n<p><canvas id="cango_gear" width="700" height="400"></canvas></p>\n<p>\n<script type="application/lua">\njs = require "js"\nwindow = js.global\nArray = js.global.Array\ncanvas = window.document:getElementById("cango_gear")\n\n-- 將 lua table 轉為 new JavaScript Object 的方法\n-- e.g. Object{mykey="myvalue"}\nfunction Object(t)\n    local o = js.new(js.global.Object)\n    for k, v in pairs(t) do\n        assert(type(k) == "string" or js.typeof(k) == "symbol", "JavaScript only has string and symbol keys")\n        o[k] = v\n    end\n    return o\nend\n\n-- javascript constructor\ncgo = js.new(window.Cango, "cango_gear")\n--local path = js.new(window.Path)\nlocal shape = js.new(window.Shape)\n-- Javascript 變數\nshapedefs = window.shapeDefs\n-- 角度轉為徑度\ndeg = math.pi/180\n\nfunction cangoGear(m, n, pa)\n    -- pr 為節圓半徑\n    pr = n*m/2 -- gear Pitch radius\n    data = js.new(window.createGearTooth, m, n, pa)\n    gearTooth = js.new(window.Path, data, Object{\n      fillColor= "#ddd0dd",\n      border= true,\n      strokeColor= "#606060" })\n    gearTooth:rotate(180/n) -- rotate gear 1/2 tooth to mesh\n    gear = gearTooth:dup()\n    for i = 1, n-1 do\n        newTooth = gearTooth:dup()\n        newTooth:rotate(360*i/n)\n        gear:appendPath(newTooth)\n    end\n\n    -- 建立軸孔\n    hr = 0.6*pr -- diameter of gear shaft\n    shaft = js.new(window.Path, shapedefs:circle(hr))\n    gear:appendPath(shaft)\n    return gear\nend\n\nn1 = 13\nn2 = 24\nn3 = 21\nreduced_ratio = 0.5\n-- 使用 80% 的畫布寬度\nm = 0.8*(canvas.width)/((n1+n2+n3)*reduced_ratio)\ncx = (canvas.width)/2\ncy = (canvas.height)/2\n-- 設定共同的壓力角\npa = 25\npr1 = n1*m/2\npr2 = n2*m/2\npr3 = n3*m/2\n-- 建立 gear\ngear1 = cangoGear(m, n1, pa)\ngear2 = cangoGear(m, n2, pa)\ngear3 = cangoGear(m, n3, pa)\n\ndeg = math.pi/180\nrotate_speed = 12*deg\n\nfunction draw()\n    cgo:clearCanvas()\n\n    gear1.transform:translate(cx-(pr1+pr2)*reduced_ratio, cy)\n    gear1.transform:scale(reduced_ratio)\n    gear1.transform:rotate(0)\n    gear1:rotate(rotate_speed)\n    cgo:render(gear1)\n    \n    gear2.transform:translate(cx, cy)\n    gear2.transform:scale(reduced_ratio)\n    gear2.transform:rotate(180+(360/n2/2))\n    gear2:rotate(-(rotate_speed)*n1/n2)\n    cgo:render(gear2)\n    \n    gear3.transform:translate(cx+(pr2+pr3)*reduced_ratio, cy)\n    gear3.transform:scale(reduced_ratio)\n    gear3.transform:rotate(180+(360/n3/2)+(180+(360/n2/2))*n2/n3)\n    gear3:rotate((rotate_speed*n1/n2)*(n2/n3))\n    cgo:render(gear3)\n    print(gear1:toString())\nend\n\n--draw()\nwindow:setInterval(draw, 2)\n</script>\n \n \n', 'tags': '', 'url': '雲端 CAD.html'}, {'title': '大學', 'text': '二十一世紀大學 \n 二十一世紀, 在網路科技的推波助瀾下, 許多行業與組織都產生了本質上的變化, 大學, 這個經常被稱為象牙塔的最後防線, 也終於必須因應全球化知識經濟的快速發展, 而做出相當程度的進化, 否則難逃被淘汰的命運. \n 從許多文獻的觀察可以得知, 二十一世紀的大學, 必須讓團隊中特定比例的成員, 擁抱知識創業的趨勢. \n 在此, 我們認為, 至少 70% 的大學成員必須俱備知識創業的能力與作為, 其餘的成員則仍能一如既往, 按照本身的認知, 從事任何自己有興趣的教學與研究, 而無需受到是否真正達到所謂知識的精進或創業獲利的約束. \n Intellectual Entrepreneurship (知識創業) \n Intellectual Entrepreneurship is a philosophy and vision of education viewing academics as "innovators" and "agents of change." It focuses on creating cross-disciplinary and multi-institutional collaborations designed to produce intellectual advancements (知識進展) with a capacity to provide real solutions (真正的解決方案) to society\'s problems and needs. Intellectual Entrepreneurship is academic engagement for the purpose of changing lives. \n Intellectual Entrepreneurship moves the mission of institutions of higher learning from "advancing the frontiers of knowledge" (推進知識前緣) and "preparing tomorrow\'s leaders" (培育未來領導人) to also "serving as engines of economic and social development." (成為經濟與社會發展的引擎) In the process, the role of faculty member and student evolves from that of "intellectual provocateur" (知識激發者)to becoming what might be called an "intellectual entrepreneur." (知識創業者) Intellectual Entrepreneurship includes a readiness to seek out opportunities, undertake the responsibility associated with each and tolerate the uncertainty that comes with initiating genuine innovation. Intellectual Entrepreneurship changes the model and metaphor of higher education from one of "apprenticeship-certification-entitlement" (學徒-認証-授權) to one of "discovery-ownership-accountability." (發現-擁有-負責) \n Intellectual Entrepreneurship is premised on the belief that intellect is not limited to the academy and entrepreneurship is not restricted to or synonymous with business. Entrepreneurship is a process of cultural innovation. (創業是一種文化創新的過程) While the creation of material wealth is one expression of entrepreneurship, at a more profound level entrepreneurship is an attitude for engaging the world. Intellectual entrepreneurs, both inside and outside universities, take risks and seize opportunities (承擔風險並緊握機會), discover and create knowledge (發現並創造知識), innovate (創新) , collaborate (協同) and solve problems in any number of social realms (解決社會範疇上的問題): corporate, non-profit, government, and education (企業, 非營利, 政府與教育單位). \n Intellectual entrepreneurs understand that genuine collaboration between universities and the public is tantamount to more than increased "access" to the academy\'s intellectual assets. It is more than "knowledge transfer"--the exportation of neatly wrapped solutions rolling off the campus conveyer belt. Collaboration demands mutual humility and respect, joint ownership of learning and co-creation of an unimagined potential for innovation--qualities that move universities well beyond the typical elitist sense of "service." Knowledge, after all, involves the integration of theory, practice and production (知識終究包括理論, 實踐與生產的整合). \n 參考資料: \n \n https://www.educause.edu/ir/library/pdf/ERM1010.pdf \xa0 or  Innovating the 21st Century University.pdf \n http://www.huffingtonpost.com/otto-scharmer/u-lab-reinventing-the-21s_b_5669425.html \n https://upcommons.upc.edu/bitstream/handle/2099/5970/2006-01_eng_van_ginkel.pdf \xa0 \n https://agenda.weforum.org/2015/05/5-ways-universities-have-already-changed-in-the-21st-century/ \n https://www.nie.edu.sg/docs/default-source/te21_docs/te21_executive-summary_14052010---updated.pdf \xa0 \n http://www.ut-ie.com/ \xa0 (知識創業) \n \n 機械工程系課程參考 \n Computer Aided Design: \n https://www.meche.engineering.cmu.edu/education/undergraduate-education/ \xa0 \n https://www.andrew.cmu.edu/course/24-681/ \xa0 \n Introduction to CAD/CAE Tools: \n http://www.andrew.cmu.edu/course/24-688/ \xa0 \n', 'tags': '', 'url': '大學.html'}, {'title': '工具', 'text': '可攜程式環境: \n p37 \xa0為\xa0 1GB 可攜程式開發套件, 解開後放入隨身碟即可使用. \n p37_adv  為 15 GB 的程式開發套件. \n Qt  則為 20GB 的程式開發套件. \n Geometirc Modeling Kernel \n Parasolid \xa0 - 由 \xa0 https://en.wikipedia.org/wiki/Shape_Data_Limited \xa0 開發, 目前在 \xa0 Siemens \xa0 旗下. \n ACIS \xa0 - 由 \xa0 https://en.wikipedia.org/wiki/Spatial_Corp \xa0 開發, 源自 \xa0 https://en.wikipedia.org/wiki/Romulus_(modelling_kernel) , 目前在 \xa0 Dassault \xa0 旗下. \n ShapeManager \xa0 - 2001 年從 \xa0 ACIS \xa0 分出, 由 AutoDesk 公司開發, 用於 Inventor. \n 參考資料: \n https://en.wikipedia.org/wiki/Geometric_modeling_kernel \xa0', 'tags': '', 'url': '工具.html'}, {'title': 'Solvespace', 'text': 'http://solvespace.com \xa0 \n Solvespace Documentation.pdf \n 利用 conda 安裝 Solvespace:\xa0 https://anaconda.org/freecad/solvespace \xa0 \n Solvespace 前身  Sketchflat  原始碼:  sketchflat.7z \n delta_printer_solvespace.7z \n delta_printer_v2.7z \n \n Slasher assembly (solvespace)  from  Phoenix Kayo  on  Vimeo . \n 參考資料: \n http://mde.tw/2017springcd/blog/midterm-collaboration-evaluation.html \xa0 \n 平面多連桿機構模擬: \n import math\nimport time\n# 利用 matplotlib 程式庫畫出 contour 輪廓\nimport matplotlib.pyplot as plt\n \nclass Coord(object):\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n \n    def __sub__(self,other):\n        # This allows you to substract vectors\n        return Coord(self.x-other.x,self.y-other.y)\n \n    def __repr__(self):\n        # Used to get human readable coordinates when printing\n        return "Coord(%f,%f)"%(self.x,self.y)\n \n    def length(self):\n        # Returns the length of the vector\n        return math.sqrt(self.x**2 + self.y**2)\n \n    def angle(self):\n        # Returns the vector\'s angle\n        return math.atan2(self.y,self.x)\n \ndef normalize(coord):\n    return Coord(\n        coord.x/coord.length(),\n        coord.y/coord.length()\n        )\n \ndef perpendicular(coord):\n    # Shifts the angle by pi/2 and calculate the coordinates\n    # using the original vector length\n    return Coord(\n        coord.length()*math.cos(coord.angle()+math.pi/2),\n        coord.length()*math.sin(coord.angle()+math.pi/2)\n        )\n \n \n# 點類別\nclass Point(object):\n    # 起始方法\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    # 加入 Eq 方法\n    def Eq(self, pt):\n        self.x = pt.x\n        self.y = pt.y\n \n    # 加入 setPoint 方法\n    def setPoint(self, px, py):\n        self.x = px\n        self.y = py\n \n    # 加上 distance(pt) 方法, 計算點到 pt 的距離\n    def distance(self, pt):\n        self.pt = pt\n        x = self.x - self.pt.x\n        y = self.y - self.pt.y\n        return math.sqrt(x * x + y * y)\n \n \n# Line 類別物件\nclass Line(object):\n \n    # 起始方法\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        # 直線的第一點, 設為線尾\n        self.Tail = self.p1\n        # 直線組成的第二點, 設為線頭\n        self.Head = self.p2\n        # 直線的長度屬性\n        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))\n \n    # setPP 以指定頭尾座標點來定義直線\n    def setPP(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        self.Tail = self.p1\n        self.Head = self.p2\n        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))\n \n    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考\n    def setRT(self, r, t):\n        self.r = r\n        self.t = t\n        x = self.r * math.cos(self.t)\n        y = self.r * math.sin(self.t)\n        self.Tail.Eq(self.p1)\n        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)\n \n    # getR 方法 for Line\n    def getR(self):\n        # x 分量與 y 分量\n        x = self.p1.x - self.p2.x\n        y = self.p1.y - self.p2.y\n        return math.sqrt(x * x + y * y)\n \n    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間\n    def getT(self):\n        x = self.p2.x - self.p1.x\n        y = self.p2.y - self.p1.y\n        if (math.fabs(x) < math.pow(10,-100)):\n            if(y < 0.0):\n                return (-math.pi/2)\n            else:\n                return (math.pi/2)\n        else:\n            return math.atan2(y, x)\n \n    # setTail 方法 for Line\n    def setTail(self, pt):\n        self.pt = pt\n        self.Tail.Eq(pt)\n        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)\n \n    # getHead 方法 for Line\n    def getHead(self):\n        return self.Head\n \n    def getTail(self):\n        return self.Tail\n \n \nclass Link(Line):\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))\n \n \nclass Triangle(object):\n    def __init__(self, p1, p2, p3):\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n \n    def getLenp3(self):\n        p1 = self.p1\n        ret = p1.distance(self.p2)\n        return ret\n \n    def getLenp1(self):\n        p2 = self.p2\n        ret = p2.distance(self.p3)\n        return ret\n \n    def getLenp2(self):\n        p1 = self.p1\n        ret = p1.distance(self.p3)\n        return ret\n \n    # 角度\n    def getAp1(self):\n        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))\n        return ret\n \n    def getAp2(self):\n        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))\n        return ret\n \n    def getAp3(self):\n        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))\n        return ret\n \n    # ends Triangle def\n    # 透過三個邊長定義三角形\n    def setSSS(self, lenp3, lenp1, lenp2):\n        self.lenp3 = lenp3\n        self.lenp1 = lenp1\n        self.lenp2 = lenp2\n        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))\n        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))\n        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))\n \n    # 透過兩個邊長與夾角定義三角形\n    def setSAS(self, lenp3, ap2, lenp1):\n        self.lenp3 = lenp3\n        self.ap2 = ap2\n        self.lenp1 = lenp1\n        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))\n        #等於 SSS(AB, BC, CA)\n \n    def setSaSS(self, lenp2, lenp3, lenp1):\n        self.lenp2 = lenp2\n        self.lenp3 = lenp3\n        self.lenp1 = lenp1\n        if(self.lenp1 > (self.lenp2 + self.lenp3)):\n        #CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間\n            ret = math.pi\n        else :\n            # CAB 夾角為 0, 三點共線且 A 不在 BC 之間\n            if((self.lenp1 < (self.lenp2 - self.lenp3)) or (self.lenp1 < (self.lenp3 - self.lenp2))):\n                ret = 0.0\n            else :\n            # 透過餘絃定理求出夾角 CAB \n                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))\n        return ret\n \n    # 取得三角形的三個邊長值\n    def getSSS(self):\n        temp = []\n        temp.append( self.getLenp1() )\n        temp.append( self.getLenp2() )\n        temp.append( self.getLenp3() )\n        return temp\n \n    # 取得三角形的三個角度值\n    def getAAA(self):\n        temp = []\n        temp.append( self.getAp1() )\n        temp.append( self.getAp2() )\n        temp.append( self.getAp3() )\n        return temp\n \n    # 取得三角形的三個角度與三個邊長\n    def getASASAS(self):\n        temp = []\n        temp.append(self.getAp1())\n        temp.append(self.getLenp1())\n        temp.append(self.getAp2())\n        temp.append(self.getLenp2())\n        temp.append(self.getAp3())\n        temp.append(self.getLenp3())\n        return temp\n \n    #2P 2L return mid P\n    def setPPSS(self, p1, p3, lenp1, lenp3):\n        temp = []\n        self.p1 = p1\n        self.p3 = p3\n        self.lenp1 = lenp1\n        self.lenp3 = lenp3\n \n        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output\n        line31 = Line(p3, p1)\n        self.lenp2 = line31.getR()\n        #self.lenp2 = self.p3.distance(self.p1)\n        #這裡是求角3\n        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))\n        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))\n        bp3 = line31.getT()\n        cp3 = bp3 - ap3\n        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x\n        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y\n        return temp\n \n# 以上為相關函式物件的定義區\n# 全域變數\nmidpt = Point(0, 0)\ntippt = Point(0, 0)\ncontour = []\n \n# 幾何位置輸入變數\nx=10\ny=10\nr=10\n \n# 其他輸入變數\ntheta = 0\ndegree = math.pi/180.0\ndx = 2\ndy = 4\n \n#set p1.p2.p3.p4 position\np1 =  Point(150,100)\np2 =  Point(150,200)\np3 =  Point(300,300)\np4 =  Point(350,100)\n \n#create links\nline1 =  Link(p1,p2)\nline2 =  Link(p2,p3)\nline3 =  Link(p3,p4)\nline4 =  Link(p1,p4)\nline5 =  Link(p2,p4)\n \nlink2_len = p2.distance(p3)\nlink3_len = p3.distance(p4)\n \ntriangle1 =  Triangle(p1,p2,p4)\ntriangle2 =  Triangle(p2,p3,p4)\n \ndef simulate():\n    global theta, midpt, oldpt\n    theta += dx\n    p2.x = p1.x + line1.length*math.cos(theta*degree)\n    p2.y = p1.y - line1.length*math.sin(theta*degree)\n    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)\n    # 計算垂直單位向量\n    a = Coord(p3.x, p3.y)\n    b = Coord(p2.x, p2.y)\n    normal = perpendicular(normalize(a-b))\n    midpt.x = (p2.x + p3.x)/2\n    midpt.y = (p2.y + p3.y)/2\n    tippt.x = midpt.x + 150*normal.x\n    tippt.y = midpt.y + 150*normal.y\n    # 印出座標點\n    #print(round(tippt.x, 2), round(tippt.y, 2))\n    if theta < 360:\n        contour.append((round(tippt.x, 2), round(tippt.y, 2)))\n \nfor i in range(180):\n    simulate()\n# 印出 contour \n#print(contour)\n \nx_list = [x for (x, y) in contour]\ny_list = [y for (x, y) in contour]\n \nplt.xlabel(\'x coordinate\')\nplt.ylabel(\'y coordinate\')\n \nplt.plot(x_list, y_list)\nplt.show() \n', 'tags': '', 'url': 'Solvespace.html'}, {'title': '程式庫範例', 'text': 'Implementation of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf \n sgcs_2_1.7z \n from math import pi, cos, sin, sqrt, acos\nimport matplotlib.pyplot as plt\n \nradian = 180/pi\ndegree = pi/180\n \n#PLAP\ndef plap(ax, ay, ac, bac, bx, by, pos):\n    if pos == 0:\n        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax \n        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay\n    else:\n        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax \n        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay\n    return cx, cy\n \n#PLLP\ndef pllp(ax, ay, ac, cb, bx, by, pos):\n    if pos == 0:\n        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n    else:\n        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))\n    return cx, cy\n\ndef crank_rocker(angle, p1x, p1y, p2x, p2y, len1, len2, len3, len4, len5):\n    p4x, p4y = plap(p1x, p1y, len1, angle, p2x, p2y, 0)\n    #print("cx=", cx, "cy=", cy)\n    p5x, p5y = pllp(p4x, p4y, len2, len3, p2x, p2y, 0)\n    #print("dx=", dx, "dy=", dy)\n    p3x, p3y = pllp(p4x, p4y, len4, len5, p5x, p5y, 0)\n    #print("ex=", ex, "ey=", ey)\n    return p3x, p3y\n    \n#主程式\nXval  = []\nYval  = []\ninc = 5\n\nfor i in range(0, 360+inc, inc):\n    try:\n        p3x, p3y = crank_rocker(i*degree, 0, 0, 90, 0, 35, 70, 70, 40, 40)\n        Xval += [p3x]\n        Yval += [p3y]\n        print(i, ":", round(p3x, 4), round(p3y, 4))\n    except:\n        pass\nprint ("Solve Completed")\n\nplt.plot(Xval, Yval)\nplt.xlabel(\'x coordinate\')\nplt.ylabel(\'y coordinate\')\n#plt.title("Involute - "+str(degree)+" deg")\nplt.show() \n \n', 'tags': '', 'url': '程式庫範例.html'}, {'title': 'Onshape', 'text': 'https://www.onshape.com/ \xa0 \n', 'tags': '', 'url': 'Onshape.html'}, {'title': 'Solidworks', 'text': '取得安裝檔案 \n', 'tags': '', 'url': 'Solidworks.html'}, {'title': 'V-rep', 'text': '內建單位 \n meters, seconds, radians, kg \n 功能 \n http://www.coppeliarobotics.com/features.html \xa0 \n 參考資料: \n http://lab.kmol.info/2017fall/blog/kmol-2017-fall-event-driven-programming-design.html \xa0 \n http://mde.tw/2017springcd/blog/vrep-introduction.html \xa0 \n One-link Robot Velocity Control \n One-link manipulator Python3 remote API program: \n Joint Properties - \n Torque/Force Mode. \n Moter enabled with Maximum torque setup and zero target velocity. \n Joint ObjectName: Revolute_joint \n import vrep\nimport sys\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,\'Revolute_joint\',vrep.simx_opmode_oneshot_wait)\n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \nerrorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)\n \nwhile True:\n    choice = input("(e to exit, p to pause and enter to exec)>")\n    if choice == "e":\n        print("exiting")\n        vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)\n        break\n    elif choice == "p":\n        vrep.simxPauseSimulation(clientID, vrep.simx_opmode_oneshot_wait)\n    else:\n        vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot_wait) \n One-link Robot Position Control \n One-link manipulator Python3 remote API program: \n Joint Properties - \n Torque/Force Mode. \n Moter enabled with Maximum torque setup and zero target velocity. \n Joint ObjectName: Revolute_joint \n import vrep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,\'Revolute_joint\',vrep.simx_opmode_oneshot_wait)\n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \ndeg = math.pi/180\n \n#errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)\n \ndef setJointPosition(incAngle, steps):\n    for i  in range(steps):\n        errorCode=vrep.simxSetJointPosition(clientID, Revolute_joint_handle, i*incAngle*deg, vrep.simx_opmode_oneshot_wait)\n \n# 每步 10 度, 轉兩圈\nsetJointPosition(10, 72)\n# 每步 1 度, 轉兩圈\n#setJointPosition(1, 720)\n# 每步 0.1  度, 轉720 步\n#setJointPosition(0.1, 720)\n \n\'\'\'\n三軸同動時\nsimxPauseCommunication(clientID,1);\nsimxSetJointPosition(clientID,joint1Handle,joint1Value,simx_opmode_oneshot);\nsimxSetJointPosition(clientID,joint2Handle,joint2Value,simx_opmode_oneshot);\nsimxSetJointPosition(clientID,joint3Handle,joint3Value,simx_opmode_oneshot);\nsimxPauseCommunication(clientID,0); \n Fourbar Linkage Velocity Control \n the First Joint properties - \n Torque/Force mode with motor enabled and target velocity 120 deg/s and maximum torque 50 N*m. \n Joint ObjectName: Revolute_joint \n All other joints with Torque/Force mode without motor enabled. \n import vrep\nimport sys\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,\'Revolute_joint\',vrep.simx_opmode_oneshot_wait)\n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \nerrorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)\n \nwhile True:\n    choice = input("(e to exit, p to pause and enter to exec)>")\n    if choice == "e":\n        print("exiting")\n        vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)\n        break\n    elif choice == "p":\n        vrep.simxPauseSimulation(clientID, vrep.simx_opmode_oneshot_wait)\n    else:\n        vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot_wait) \n Fourbar Linkage Position Control \n V-rep Fourbar linkage remote API program: \n the First Joint properties - \n Passive mode with Hybrid operation. \n Position control (PID) with proportional parameter 0.1 without I and D controls. \n Joint ObjectName: Revolute_joint \n All other joints properties - \n Inverse kinematics mode with Hybrid operation. \n Position control (PID) with proportional parameter 0.1 without I and D controls. \n import vrep, math\nimport sys\n# child threaded script: \n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,\'Revolute_joint\',vrep.simx_opmode_oneshot_wait)\n \ndeg = math.pi/180\n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \n#errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)\n \ndef setJointPosition(incAngle, steps):\n    for i  in range(steps):\n        errorCode=vrep.simxSetJointPosition(clientID, Revolute_joint_handle, i*incAngle*deg, vrep.simx_opmode_oneshot_wait)\n \n# 每步 10 度, 轉兩圈\nsetJointPosition(10,72) \n 與上述四連桿位置控制流程相同, 但是由 Python3 remote API 程式負責控制 V-rep 的模擬啟動與模擬終止. \n import vrep, math\nimport sys\n# child threaded script: \n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n#啟動模擬\nvrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,\'Revolute_joint\',vrep.simx_opmode_oneshot_wait)\n \ndeg = math.pi/180\n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \n#errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)\n \ndef setJointPosition(incAngle, steps):\n    for i  in range(steps):\n        errorCode=vrep.simxSetJointPosition(clientID, Revolute_joint_handle, i*incAngle*deg, vrep.simx_opmode_oneshot_wait)\n    #終止模擬\n    vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)\n \n# 每步 10 度, 轉兩圈\nsetJointPosition(10, 72) \n 兩軸同動資料傳送: \n import vrep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,\'Revolute_joint\',vrep.simx_opmode_oneshot_wait)\n \nerrorCode0,Revolute_joint_handle0=vrep.simxGetObjectHandle(clientID,\'Revolute_joint0\',vrep.simx_opmode_oneshot_wait)\n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \ndeg = math.pi/180\n \n#vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot)\n \nfor i in range(36):\n    vrep.simxSynchronous(clientID,True)\n    vrep.simxPauseCommunication(clientID,True)\n    vrep.simxSetJointPosition(clientID, Revolute_joint_handle, 10*deg, vrep.simx_opmode_oneshot)\n    vrep.simxSetJointPosition(clientID, Revolute_joint_handle0, 10*deg, vrep.simx_opmode_oneshot)\n    vrep.simxPauseCommunication(clientID, False)\n    vrep.simxSynchronous(clientID, False)\n \n    vrep.simxSynchronous(clientID,True)\n    vrep.simxPauseCommunication(clientID,True)\n    vrep.simxSetJointPosition(clientID, Revolute_joint_handle, -10*deg, vrep.simx_opmode_oneshot)\n    vrep.simxSetJointPosition(clientID, Revolute_joint_handle0, -10*deg, vrep.simx_opmode_oneshot)\n    vrep.simxPauseCommunication(clientID, False)\n    vrep.simxSynchronous(clientID, False)', 'tags': '', 'url': 'V-rep.html'}, {'title': 'Git', 'text': 'https://git-scm.com/ \xa0 \n https://git-scm.com/book/zh-tw/v2 \xa0 \n https://github.com/ \xa0 \n http://www.globallegalchronicle.com/microsofts-7-5-billion-acquisition-of-github/ \xa0 \n git 常用指令 \n git add . \n 新增所有改版內容 \n git commit -m "提交訊息, 用來辨識版本" \n 在近端提交改版內容 \n git push \n 將近端改版內容推送到遠端 \n git pull \n 拉下遠端新版本內容, 在 fossil scm 使用 fossil update \n git log \n 查驗 git 提交推送紀錄 \n git status \n 查驗狀態 \n git 新增提交推送的身分綁定 \n 以 scrum1@mde.tw 註冊帳號為 scrum-1 為例: \n git config --global user.name "scrum-1" \n git config --global user.email "scrum1@mde.tw" \n 若網路直接連線過慢, 可以透過 proxy 執行 git \n git config --global http.proxy http://proxy.kmol.info:3128 \n 以上的 git config 會將設定存入 Y:/home/.gitconfig 檔案中 \n 刪除近端與遠端的 Git 分支. \n To delete a local branch \n git branch -D the_local_branch \n To remove a remote branch \n git push origin :the_remote_branch \n or \n git push origin --delete the_remote_branch \n', 'tags': '', 'url': 'Git.html'}, {'title': 'Leo Editor', 'text': 'http://www.leoeditor.com/ \xa0 \n', 'tags': '', 'url': 'Leo Editor.html'}, {'title': 'SCiTE', 'text': 'https://www.scintilla.org/SciTE.html \xa0 \n 利用 SciTE 執行 Pelican 網誌 Markdown 轉為 html: \n SciTEUser.properties 設定 \n 以下的設定, 是將近端與遠端 \xa0 Pelican \xa0 轉檔指令, 設為 Pelican-blog 與 Github-blog 下拉式功能表, 位於 Tools-Go 下方, 唯一的限制是, 當執行這兩個指令時, \xa0 SciTE \xa0 必須處於開啟 content 目錄之外的 local_publishconf.py 檔案, 因為 \xa0 SciTE \xa0 會以開啟檔案所在目錄, 執行所設定的 \xa0 Pelican \xa0 指令. \n import Properties\\python\nimport _platform\nimport _config\n \n#~ #  1142  Pelican-blog\ncommand.name.42.*=Pelican-blog\ncommand.42.*="pelican content -o blog -s local_publishconf.py"\n#command.subsystem.42.*=2\n#command.quiet.42.*=1\ncommand.shortcut.42.*=Ctrl+Shift+P\n \n#~ #  1143 Github-blog\ncommand.name.43.*=Github-blog\ncommand.43.*="pelican content -o blog -s publishconf.py"\n#command.subsystem.42.*=2\n#command.quiet.42.*=1\ncommand.shortcut.43.*=Ctrl+Shift+G \n \n 啟動 IPv4 或 IPv6 www 伺服器\n 當 \xa0 Pelican \xa0 轉檔指令執行結束後, \xa0 SciTE \xa0 會在輸出區列出執行結束訊息, 若轉檔過程發生錯誤, 也會一併顯示. 之後為了檢視轉換完成的近端簡報或網誌檔案, 必須將原先位於 \xa0 Leo Editor \xa0 button 區的按鈕 Python3 程式移出, 分別存為 .py 檔案. \n 由於原先的 \xa0 Leo Editor \xa0 button 位於 users 目錄中執行, 因此轉出的 .py 檔案也存入 users 目錄中, 程式內容如下: \n users/ipv4_www_server.py 程式檔 \n #ipv4_www_server.py 存入 users 目錄\nimport os\nimport subprocess\nimport threading\nimport http.server, ssl\n \ndef domake():\n    # build directory\n    os.chdir("./../")\n    server_address = (\'localhost\', 5443)\n    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)\n    httpd.socket = ssl.wrap_socket(httpd.socket,\n                                   server_side=True,\n                                   certfile=\'localhost.crt\',\n                                   keyfile=\'localhost.key\',\n                                   ssl_version=ssl.PROTOCOL_TLSv1)\n    print(os.getcwd())\n    print("5443 https server started")\n    httpd.serve_forever()\n \n# 利用執行緒執行 https 伺服器\nmake = threading.Thread(target=domake)\nmake.start() \n users/ipv6_www_server.py 程式檔 \n #ipv6_www_server.py 存入 users 目錄\nimport os\nimport subprocess\nimport threading\nimport socket\nimport http.server, ssl\n \nclass HTTPServerV6(http.server.HTTPServer):\n    address_family = socket.AF_INET6\n \ndef domake():\n    # build directory\n    os.chdir("./../")\n    ipv6_address = \'::1\'\n    server_address = (ipv6_address, 6443)\n    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)\n    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)\n    httpd.socket = ssl.wrap_socket(httpd.socket,\n                                   server_side=True,\n                                   certfile=\'localhost.crt\',\n                                   keyfile=\'localhost.key\',\n                                   ssl_version=ssl.PROTOCOL_TLSv1)\n    print("6443 https server started")\n    httpd.serve_forever()\n \n# 利用執行緒執行 https 伺服器\nmake = threading.Thread(target=domake)\nmake.start() \n \n \n', 'tags': '', 'url': 'SCiTE.html'}, {'title': 'TinyCC', 'text': 'https://bellard.org/tcc/ \xa0 \n', 'tags': '', 'url': 'TinyCC.html'}, {'title': 'CMSimfly', 'text': 'https://github.com/chiamingyen/cmsimfly \n', 'tags': '', 'url': 'CMSimfly.html'}, {'title': '實習操作', 'text': '機械手臂運動學  (Robot manipulator kinematics) \n RobotKinematicsII.pdf \n Machines and Mechanism.pdf \n https://sajidnisar.github.io/posts/python_kinematics_dh \xa0 \n 何謂正向運動學 (Forward kinematics)? \n 何謂 逆向運動學 (Inverse kinematics)? \n Onshape\xa0Document Links \n Here is a list of Onshape document links that we reference in our curriculum ( LP  for “Lesson Plan”,  HW  for “Homework”). It might be beneficial for the students to see the final model in case they get stuck during the exercises. \n basics_of_mechanical_engineering.pdf \n Managing your Onshape Account.pdf \n How to Use the College Curriculum.pdf \n College Curriculum Outline.pdf \n Public Document Links.pdf \n', 'tags': '', 'url': '實習操作.html'}, {'title': 'OnshapeWeek 1', 'text': '1-1-Lesson Plan.pdf \n 1-2-Homework.pdf \n 1-3-Assessment.pdf \n 1-3-Assessment (Answers).pdf \n LP:  College - Casting Fixture Demo \n https://cad.onshape.com/documents/57092e16e4b0b7d723cf1127/w/436e8c84e0076428ce162d7f/e/3fc169118c16ca90beee0f70   \n LP:  College - Sketch-Based Modeling  \n https://cad.onshape.com/documents/e499c16fe529b1b8a3859bfa/w/0b66b0a7d92360b486939300/e/fb726ff7d818375ee7e0de76   \n LP:  College - Week 1 \n https://cad.onshape.com/documents/9bafe70c19d844329890ef98/w/97ea5e00fc97edcff17adc05/e/35f8dd8999d69d2c35f05146 \n HW:  College - Pre-made Sketches \n https://cad.onshape.com/documents/06aebdf92d8bcb7e898a67ff/w/8e655f093932843575ed2b5d/e/4f9d406193e90df25a5e7588   \n HW:  College - Week 1 Homework \n https://cad.onshape.com/documents/c28554e4f648233ed223b53d/w/1df334f6179810c3d0af44a0/e/0ad0d33e9882deb1c2dcd530   \n \n \xa0學習要點 \n \n 建立 Onshape 帳號 - 請利用學校 gmail 建立教育版帳號 \n 3D 環境導航 (navigate) \n 說明基於草圖 (sketch-based)的建模 \n 介紹 4 個基本特徵 (features)（擠出(extrude)，旋轉(revolve)，掃描(sweep)，和斷面混成(loaf)） \n 從 2D 過渡到 3D \n 介紹基本草圖 \n 附錄A：鍵盤快捷鍵 (keyboard shotcuts)，滑鼠和觸控平面手勢 (touchpad gestures)，檢視工具 \n 附錄B：導航說明檔，建立帳號，訂閱計劃 (subscription plans) \n 圓柱薄殼 (cylinder shell) - 繪圖界面與可視化/檢視的介紹 \n 針對既有草圖的模型 - 接續建立特徵 \n 現存公用模型 (public models) - 如何搜尋並復製到工作區 (workspace) \n', 'tags': '', 'url': 'OnshapeWeek 1.html'}, {'title': 'Onshape1-1', 'text': 'Lesson 1 教材:  1-1-Lesson Plan.pdf \n 英文單字查詢 \n 若碰到英文單字, 請查詢  https://www.merriam-webster.com \xa0, 例如: \n https://www.merriam-webster.com/dictionary/navigate \xa0 \n https://www.merriam-webster.com/dictionary/intransitive \xa0verb \n https://www.merriam-webster.com/dictionary/sketch \xa0 \n https://www.merriam-webster.com/dictionary/transition \xa0 \n https://www.merriam-webster.com/dictionary/appendix \xa0 \n https://www.merriam-webster.com/dictionary/supplementary \xa0 \n https://www.merriam-webster.com/dictionary/subscription \xa0 \n https://www.merriam-webster.com/dictionary/cylinder \xa0 \n https://www.merriam-webster.com/dictionary/appurtenant \xa0 \n https://www.merriam-webster.com/dictionary/visualization \xa0 \n https://www.merriam-webster.com/dictionary/feature \xa0 \n https://www.merriam-webster.com/dictionary/prominent \xa0 \n https://www.merriam-webster.com/dictionary/characteristic \xa0 \n https://www.merriam-webster.com/dictionary/protuberant \xa0 \n https://www.merriam-webster.com/dictionary/conspicuous \xa0 \n https://www.merriam-webster.com/dictionary/curriculum \xa0 \n https://www.merriam-webster.com/dictionary/platform \xa0 \n https://www.merriam-webster.com/dictionary/declaration \xa0 \n https://www.merriam-webster.com/dictionary/logarithm \xa0 \n https://www.merriam-webster.com/dictionary/integer \xa0 \n https://www.merriam-webster.com/dictionary/entity \xa0 \n https://www.merriam-webster.com/dictionary/contrast \xa0 \n https://www.merriam-webster.com/dictionary/attribute \xa0 \n https://www.merriam-webster.com/dictionary/scrape \xa0 \n 只要逐一閱讀 Onshape 教學文件,\xa0 從各單字的英英字典查詢中, 找出用來解釋這些單字的相關單字, 並用心了解各單字的字意與用法, 假以時日, 就能更順暢直接閱讀各種英文資料. \n 開始學習 Onshape \n Onshape 是一套純雲端 MCAD (Mechanical Computer Aided Design) 套件, 可以利用電腦中的瀏覽器, 手機或平板中的 App, 就可以執行 2D/3D 零組件設計繪圖. \n 有關 Onshape 如何建立零組件, 請參考: \n https://www.onshape.com/cad-blog/under-the-hood-how-does-onshape-really-work \xa0 \n Onshape 是一套雲端應用程式 \n 雲端應用的特性是: 用多少運算資源, 才開啟多少運算資源, 可最佳化且不至超載. \n Onshape is like any other large-scale modern cloud application – a collection of servers and services. They can run on machines optimized for their purposes; and the number of instances can be optimized so that they are always busy, but not overloaded, to make efficient use of resources. \n 認證伺服器 \n Some servers that handle things (such as user authentication and authorization, and finding and listing documents) process lots of requests, but do not do much “real work” themselves. They forward complex requests to other servers. Others know what is “inside” a document, and keep modeling sessions in memory, resulting in long-lasting sessions for modeling with documents. \n 幾何運算伺服器 \n Onshape 的幾何模擬核心採用 Parasolid \n Onshape 採用 D-Cubed 解繪圖過程中的幾何約束條件 \n Others, the admittedly unimaginatively named “geometry servers,” do all the math – these are optimized for computation power. These servers are the ones that reconstruct geometry from feature lists and FeatureScript, solve for instance positions in assemblies, and compute graphical tessellations. They make use of the venerable geometric modeling kernel Parasolid and constraint solver D-Cubed – both well-tested by many years of use in many CAD systems – which we license from Siemens PLM. \n 參考資料: \n https://en.wikipedia.org/wiki/Geometric_constraint_solving \xa0 \n A geometric constraint solver.pdf \n Geometric Constraint Solving in Parametric CAD.pdf \n 1996_Solving\xa0 Geometric Constraints by Homotopy.pdf \n Geometric_constraint_solver_These-Moussaoui_Nov_2016.pdf \n Decomposition of Geometric Constraint Systems - a Survey.pdf \n https://www.pyslvs.com/content/ \xa0 \n Implementation of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf \n https://github.com/mdecourse/pyslvs_demo/blob/master/triangle/triangle_foubar._point_track.py \xa0 \n https://github.com/mdecourse/pyslvs_demo/blob/master/sgcs/sgcs_2_1.py \xa0 \n https://computergraphics.stackexchange.com/questions/3651/solving-a-set-of-geometry-constraints-whats-that-method-called \xa0 \n https://github.com/chiamingyen/PythonCAD_py3 \xa0 \n http://geosolver.sourceforge.net/ \xa0 \n https://github.com/cmerrill/sketchsolve \xa0 \n https://bitbucket.org/geoplexity/frontier \xa0 \n https://en.wikipedia.org/wiki/Parasolid \n https://www.plm.automation.siemens.com/global/en/products/plm-components/parasolid.html \xa0 \n PlantGL - A Python-based geometric library for 3D plant modelling at different scales.pdf \n MCAD 分類 \n 1987-2017 \n mid-range MCAD:  AutoDesk Inventor ,  Solidworks ,  Solid Edge ,  IronCAD ,  ZWCAD \n high-end MCAD:  NX ,  Creo ,  Catia \n cloud MCAD:  Onshape ,  Fusion 360  (Hybrid) \n Machine Learning \n Scikit-learn - Machine Learning in Python.pdf \n https://github.com/scikit-learn/scikit-learn \xa0 \n http://scikit-learn.org \xa0', 'tags': '', 'url': 'Onshape1-1.html'}, {'title': 'OnshapeWeek 2', 'text': '2-1-Lesson Plan.pdf \n 2-2-Homework.pdf \n 2-3-Assessment.pdf \n 2-3-Assessment (Answers).pdf \n LP:  College - Clock \n https://cad.onshape.com/documents/57a4a3a2e4b0a16f2a0c90bd/w/ece3b9b944dc0d1aea87f726/e/9e2433ad093f8152215de0e5   \n LP and HW:  College - Week 2 \n https://cad.onshape.com/documents/570c509de4b0b585da448d8c/w/a187923b0b25e8418f1d75b9/e/fb779d9a569edde8b30114ee \n \n 學習要點 \n \n 簡介"設計意圖" (design intent) \n 設定尺寸 (dimensions) 與約束 (constraints) \n 自動推理 (automatic inferencing) \n 繪製精確的零件 (accurate part) \n 草圖繪製練習 \n 運用與建立平面 (planes) \n 建立圓角 (fillets) 與倒角 (chamfers) \n 使用多個 (multiple) 草圖區域 (sketch regions) \n 基本零件 \n 繪製時鐘模型 - 用於設計意圖教學 \n 各種簡單的幾何形狀 (geometric shapes)\xa0 \n \n Design Intent is the practice of developing your project’s objectives and requirements even before working on your design. \n 設計意圖指在設計進行前, 必須完成之專案目的與需求確認 \n The more complex the geometry, the more we need to think about how we want to design the parts before just going ahead and making it. \n 幾何外型越複雜, 越需要在零件設計之前做好設計意圖的確認 \n Design intent goes hand-in-hand with Dimensions and Constraints. Dimensions refer to the distance and angle values of sketch entities. Constraints refer to the geometric relationships and rules within a sketch. \n 英文單字 \n https://www.merriam-webster.com/dictionary/entity \xa0 \n https://www.merriam-webster.com/dictionary/precise \xa0 \n https://www.merriam-webster.com/dictionary/dip \xa0 \n https://www.merriam-webster.com/dictionary/primarily \xa0 \n https://www.merriam-webster.com/dictionary/intent \xa0 \n \xa0 https://www.merriam-webster.com/dictionary/enclose \xa0 \n https://www.merriam-webster.com/dictionary/purposeful \xa0', 'tags': '', 'url': 'OnshapeWeek 2.html'}, {'title': 'OnshapeWeek 3', 'text': '3-1-Lesson Plan.pdf \n 3-2-Homework.pdf \n 3-3-Assessment.pdf \n 3-3-Assessment (Answers).pdf \n LP:  College - Boolean Operations \n https://cad.onshape.com/documents/5787b5d9e4b050a40b9da3f2/w/95a28f9e1a1782c93ffcf4ac/e/99eeec404fea49295eba8539 \n LP : College - Boolean Intersect \n https://cad.onshape.com/documents/fdaafc5a94e4406f29799a5b/w/cc6c7f69c96de92051c8a6a1/e/3af775362a71e1faa6bc4445   \n LP:  College - Linear Part Pattern  \n https://cad.onshape.com/documents/57a4b2b7e4b04351c9601824/w/c006b121241bbbc9f2f9f6cb/e/0e59d4bd96c87cae6124a92a   \n LP:  College - Circular Part Pattern \n https://cad.onshape.com/documents/57a4b2d4e4b04351c9601864/w/ff908d7bbce7afeed1ac9871/e/1fc57a418efdd5ca0b4600c5 \n LP:  College - Week 3 (“Cantilever Clamp” Part Studio) \n https://cad.onshape.com/documents/56f5c963e4b00c5ed10c717f/w/131859f16f9a995fc9895acc/e/c343c081da32fcb3bb7f0e2e   \n HW:  College - Week 3 Homework \n https://cad.onshape.com/documents/7b5553135cdf6caafa9a6946/w/549bd8008ce6e8a13dc6b6cf/e/27159315ac3670adb78c8eec   \n 學習要點: \n \n Using  Boolean operations \n Applying linear and circular patterning\xa0 \n Applying mirror tool \n Assemblies in Onshape \n  An introduction to concurrent top-down and bottom-up designs\xa0 \n  Creating a Multi-Part design in a Part Studio \n \n Multi-Part Modeling \n Unlike other CAD systems, you may make as many parts in a single Part Studio as you want. This technique is called Multi-Part Modeling and it’s very powerful because, as we’ve seen, you can make parts that highly depend on one another.\xa0 \n Buttom-Up Design \n Bottom-Up Design is when a product is designed by creating sketches, then features, then parts (often one per Part Studio), and then assemblies. In this approach, the geometry is created starting with the lower level entities (like 2D lines and circles) up the hierarchy to the highest level assembly (such as the final product being built). \n Top-Down Design \n Top-Down Design is when the shape of an overall product is sketched first, and then different regions of that sketch are used to create the lower level parts and their features. Top-Down is a more intuitive way to approach a design because typically we, as designers, envision the final product first, then as time goes on, we refine the concept into finer and finer detail.  \n 英文單字: \n https://www.merriam-webster.com/dictionary/pattern \xa0 \n https://www.merriam-webster.com/dictionary/nozzle \xa0 \n https://www.merriam-webster.com/dictionary/cantilever \xa0 \n \xa0', 'tags': '', 'url': 'OnshapeWeek 3.html'}, {'title': 'OnshapeWeek 4', 'text': '4-1-Lesson Plan.pdf \n 4-2-Homework.pdf \n 4-3-Assessment.pdf \n 4-3-Assessment (Answers).pdf \n LP:  College - Week 3 (“Cantilever Clamp” Assembly) \n https://cad.onshape.com/documents/56f5c963e4b00c5ed10c717f/w/131859f16f9a995fc9895acc/e/c343c081da32fcb3bb7f0e2e   \n LP:  College - Assembled Vise \n https://cad.onshape.com/documents/56f66af8e4b00c5ed10c8de5/w/4b4754abd47ac94d28ed28a1/e/a94e71506e52d57b06a002ce   \n HW:  College - Week 4 \n https://cad.onshape.com/documents/3dfea8a48b63966179b186fb/w/862e37d0732da731dfd01eff/e/317d93354922ee3e4db59e79   \n 學習要點: \n \n Lesson on degrees of freedom  \n An introduction to assembly Mates \n  Mate Connectors \n Manipulating part position with the triad \n Explaining Mates and Relations \n Animating Mates  \n An introduction to Linked Documents \n Applying limits to a Mate \n \n Assembly and Mate Connector \n For designing and manufacturing an assembly, it is important to know which parts go into the assembly, how many of each, how they are assembled, and how they should perform.\xa0 \n  A Mate in Onshape fully describes how two parts will interact with each other by specifically controlling each degree of freedom through the use of things called Mate Connectors. You can think of a Mate Connector as a small, local coordinate system (an x, y, and z axis) for a joint between two parts. The Red line is the X-axis, the Green is the Y, and the Blue is the Z. \n \xa0Animations  \n Animations are a great way to view the motion of your Mate before accepting it. Onshape will automatically move the Mate in a way that will exercise the Degrees of Freedom. In a Revolute Mate the part will rotate, in a Slider Mate, the part will slide, in a Cylinder Mate, the part will slide and rotate, etc. \n Relations and Limits \n A relation is a way in Onshape to constrain degrees of freedom between two Mates. Where a Mate controls how many degrees of freedom a pair of parts has between them, a Relation can control how those degrees of freedom move with respect to each other. There are 4 types of Relations in Onshape: Gear, Rack and Pinion, Screw, and Linear. These relations rely on preexisting Mates to define the type of motion that will occur between two parts.', 'tags': '', 'url': 'OnshapeWeek 4.html'}, {'title': 'OnshapeWeek 5', 'text': '5-1-Lesson Plan.pdf \n College - Week 5 - Part 1 Dwg.pdf \n College - Week 5 - Part 2 Dwg.pdf \n College - Week 5 - Part 3 Dwg.pdf \n College - Week 5 - Part 4 Dwg.pdf \n College - Week 5 - Part 5 Drawing - Week 2.pdf \n 5-2-Homework.pdf \n Week 5 Homework Q1.pdf \n Week 5 Homework Q2 - End Hinge Dwg.pdf \n Week 5 Homework Q2 - Long Arm Dwg.pdf \n Week 5 Homework Q2 - Short Arm Dwg.pdf \n Week 5 Homework Q2 - Threaded Hinge Dwg.pdf \n Week 5 Homework Q3.pdf \n 5-3-Assessment .pdf \n 5-3-Assessment (Answers).pdf \n LP:  College - Week 5 \n https://cad.onshape.com/documents/020fe0bde2dec1bf6f852379/w/63c455d4d5a1376cbf8d6a5f/e/27ef743a8c6e7ea214132c0b   \n HW:  College - Week 5 Homework \n https://cad.onshape.com/documents/460bf1fa05de52578c3d3ddd/w/3c7ab94e26d9cfbf9c707615/e/25b07b0a1aff8e9b9cadcd59   \n 學習要點: \n \n An introduction to engineering drawings  \n Creating drawing views, dimensioning, tolerancing, notes \n Using formats/templates \n Introducing GTOL/GD&T \n \n \xa0 \n \xa0', 'tags': '', 'url': 'OnshapeWeek 5.html'}, {'title': 'OnshapeWeeks 6-8', 'text': '6-0-Special Instructions for Week 6.pdf \n 6-1-Lesson Plan (Student A).pdf \n 6-1-Lesson Plan (Student B).pdf \n Speaker_small.STEP \n Speaker_large.STEP \n 6-2-Homework.pdf \n 6-3-Assessment.pdf \n 6-3-Assessment (Answers).pdf \n \n 7-1-Lesson Plan.pdf \n 7-2-Homework.pdf \n 7-3-Assessment.pdf \n 7-3-Assessment (Answers).pdf \n \n 8-1-Lesson Plan.pdf \n 8-2-Homework.pdf \n 8-3-Assessment.pdf \n 8-3-Assessment (Answers).pdf \n College - Bluetooth Speaker \n https://cad.onshape.com/documents/a698f9126f4e875c16ad8968/w/9724465b8fc7953cf33bdf04/e/d26e14ad0455fde3d4f013ed   \n HW:  College - Week 6 Homework \n https://cad.onshape.com/documents/1fbde283058f127d8798a39c/w/5d28e2ad003fcd5abe6716e8/e/720532d29c32a2f194d413a0 \n \xa0 \n \xa0 \n', 'tags': '', 'url': 'OnshapeWeeks 6-8.html'}, {'title': 'OnshapeWeeks 9-12', 'text': '9-1-Lesson Plan.pdf \n 9-2-Homework.pdf \n 9-3-Assessment.pdf \n 9-3-Assessment (Answers).pdf \n \n 10-1-Lesson Plan.pdf \n Electric Motor.zip  (SolidWorks files) \n 10-2-Homework.pdf \n 10-3-Assessment.pdf \n 10-3-Assessment (Answers).pdf \n \n 11-1-Lesson Plan.pdf \n \n 11-2-Homework.pdf \n 11-3-Assessment.pdf \n 11-3-Assessment (Answers).pdf \n \n 12-1-Lesson Plan.pdf \n 12-2-Homework.pdf \n 12-3-Assessment.pdf \n 12-3-Assessment (Answers).pdf \n Mini_Chopper_PO_example.pdf \n Course Wrap-Up.pdf \n College - Mini Chopper \n https://cad.onshape.com/documents/160e67bd4f8c8c97d9543ac0/w/5367d8cc3fe60c57c5e28b91/e/857782f106546f7b44433273   \n HW:  College - Week 10 Homework \n https://cad.onshape.com/documents/808c7aed719a892f8ff3d8f9/w/11e0a51e4c6e3148d5d89c45/e/fe3b9019fc9e051990830726   \n HW:  College - Week 11 Homework \n https://cad.onshape.com/documents/3fa393fac2ba5807ebae1d61/w/ecfbcd14db253e714128a69f/e/3f352a87833fd9e59496e700   \n \n \n', 'tags': '', 'url': 'OnshapeWeeks 9-12.html'}, {'title': '應用範例', 'text': '學習電腦輔助設計實習的目的在利用數位科技技術解決問題, 所謂數位科技技術包括程式套件、網路與資料庫等元件的組合. \n 基本流程為: \n \n 如何取得、傳輸並處理資料? \n 如何儲存資料? \n 如何呈現資料? \n \n 處理資料的過程依賴數學模型、演算法與資料結構 \n 取得與傳輸資料則依賴網路 \n 至於資料的呈現則涵蓋 2D/3D 動態與靜態格式處理 \n \n Tinkercad Circuit - Arduino 控制卡與電子致動與感測元件線路的模擬 \n 網頁資料解讀與任務派送 - 計算機程式對特定格式資料的分析後, 依照循環與亂數流程進行分配 \n V-rep - 利用各種程式介面與延伸程式的設計, 讓使用者設計、控制並模擬各種機器人模型 \n 輔助設計套件 - 利用計算機圖學與視窗介面, 讓使用者完成設想中的機械零組件設計, 並進行功能模擬 \n \n', 'tags': '', 'url': '應用範例.html'}, {'title': 'Tinkercad', 'text': "註冊 AutoDesk TinkerCAD 帳號 \n 為了在實體 Arduino Uno 控制板連線操作之前, 可以利用網際 Auduino 控制板與電子元件系統進行模擬, 請各學員至 \xa0 https://www.tinkercad.com \xa0 登記帳號, 登入後選擇左上角的 TinkerCAD 標誌連結後, 選擇 Circuits 進入電路設計與模擬, 操作畫面如下圖所示: \n \n 接著選擇 Arudino Uno 控制板與 Servo Motor, 然後接上電源與地線, 並將控制訊號接到 Auduino Uno 控制板的 PWM pin 9, 利用 Code Editor 納入下列 Arduino 程式, 再利用 upload and run 將程式編譯後上傳到虛擬的 Arduino Uno 控制板上執行, 就可以模擬 Servo Motor 持續左右各旋轉 180 度. 操作畫面如下圖所示:\xa0 \n \n 實體 Arduino Servo Motor Control \n 完成上述以 TinkerCAD 模擬伺服馬達的接線與程式執行之後, 接著操作實體 Arduino 控制板與 Servo Motor 的控制, 首先利用電腦驅動 Arduino 控制板, 然後再利用板子上的脈衝寬度調變 (PWM, Pulse Width Modulation) 訊號控制伺服馬達, 之後再利用傳動機構與資訊控制介面, 製作所需的機電資整合系統. 電子電機系統除了可以方便感測各種物理化學量外, 還能夠快速傳遞感測與命令訊號, 而機械系統則透過機構元件的組合, 扮演傳遞功率致動或抵抗外力撞擊與疲勞破壞的角色, 至於資訊系統則用來整合各種資訊, 用更友善的人機介面, 讓使用者更有效能地運用機電資系統產品. \n arduino-1.8.4-windows.zip \xa0 下載 (或直至 \xa0 https://www.arduino.cc/en/Main/Software \xa0 下載) \n 控制台 - 硬體與音效 - 裝置管理員 利用解開的 arduino driver 程式驅動 Arduino Uno 控制板, 並取得 COM 對應號碼, 例如: COM7, 之後的 Arduino 編譯後可以透過此 COM 埠號將程式上傳到控制板上執行. \n MG996R 伺服馬達 \n 棕色線 GND \n 紅色線 V+5V \n 橘色線 PWM \n 控制程式: \n #include <Servo.h>\nServo myservo;  // 建立一個 servo 物件，最多可建立 12個 servo\n\nint pos = 0;    // 設定 Servo 位置的變數\n\nvoid setup() {\n  myservo.attach(9);  // 將 servo 物件連接到 pin 9\n}\n\nvoid loop() {\n  // 正轉 180度\n  for (pos = 0; pos <= 180; pos += 1) // 從 0 度旋轉到 180 度，每次 1 度 \n  {     \n    myservo.write(pos);               // 告訴 servo 走到 'pos' 的位置\n    delay(15);                        // 等待 15ms 讓 servo 走到指定位置\n  }\n\n// 反轉 180度\n  for (pos = 180; pos >= 0; pos -= 1) // 從 180 度旋轉到 0 度，每次 1 度 \n  { \n    myservo.write(pos);               // 告訴 servo 走到 'pos' 的位置\n\ndelay(15);                        // 等待 15ms 讓 servo 走到指定位置\n  }\n} \n 參考資料: \n Beginning Arduino \n iot_arduino.pdf \n Beginning Arduino Programming \n http://www.playrobot.com/20kgf-cm/1150-standard-servo-mg996r.html \n http://www.playrobot.com/freedownload/Arduino_Happy%20Learning_DEMO.pdf \n http://atceiling.blogspot.tw/2017/03/arduino.html \n Python, Arduino and VPython: \n http://www.toptechboy.com/arduino-lessons/ \n Arduino Magnetic Levitation System \n http://www.instructables.com/id/Magnetic-Levitation/ \xa0 ( 電磁鐵1 , \xa0 電磁鐵2 ) \n Arduino and PyQt5 \n http://embeddedlaboratory.blogspot.tw/search/label/Arduino \n Arduino and Matplotlib \n 無碳刷直流馬達運作原理: \n \n 步進馬達運作原理: \n \n 伺服馬達運作原理: \n \n 伺服馬達與步進馬達差異: \n \n 開放迴路與封閉迴路控制步進馬達差異: \n \n", 'tags': '', 'url': 'Tinkercad.html'}, {'title': '解讀網頁內容', 'text': 'Onshape 教學影片 \n https://www.onshape.com/video \xa0 為 Onshpae 官方網站所提供的教學影片區, 請各班以每人兩個影片的方式進行分配, 分別以中文說明影片內容操作過程, 並上傳到個人的 Vimeo 與 Youtube 影片區. \n 預計分配的影片: \n https://www.onshape.com/videos/topic/tech-tips \n https://www.onshape.com/videos/topic/intro-to-cad \n https://www.onshape.com/videos/topic/tutorials \n https://www.onshape.com/videos/topic/essential-training \n https://www.onshape.com/videos/topic/drawings \n 請各組討論: \n 如何分配影片?如何集合管理各學員所上傳的教學操作影片? \n 利用 Python3, urllib 與 bs4 解讀上述網頁內容, 取出各影片的連結, 然後放入數列中: \n from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\n\nfile = urlopen("https://www.onshape.com/videos/topic/intro-to-cad")\n#print(file.read().decode())\n\nsoup = BeautifulSoup(file, \'html.parser\')\n\nlinks = []\nfor link in soup.find_all(\'a\', href=True):\n    if \'videos\' in link[\'href\']:\n        if \'https\' in link[\'href\']:\n            #print(link[\'href\'])\n            links.append(link[\'href\'])\nresult = list(set(links))\nfor i in range(len(result)):\n    print(i+1, result[i]) \n 納入上述所有影片網頁連結, 利用程式取出各影片的連結字串: \n # 從 urllib 模組中導入 urlopen\nfrom urllib.request import urlopen\n# 從 bs4 模組中導入 BeautirulSoup\nfrom bs4 import BeautifulSoup\n\n# 將要取出影片連結的網站 url,  放入數列中, 取名為 sources\nsources = [\'https://www.onshape.com/videos/topic/tech-tips\', \'https://www.onshape.com/videos/topic/intro-to-cad\', \'https://www.onshape.com/videos/topic/tutorials\', \'https://www.onshape.com/videos/topic/essential-training\', \'https://www.onshape.com/videos/topic/drawings\']\n\n#tech-tips (60)\n#intro-to-cad (26)\n#tutorials (14)\n#essential-training (6)\n#drawings (5)\n\n# 按照網頁中的影片數計算, 共有 111 部影片, 但分類中可能重複\nprint(60+26+14+6+5)\n\n# 設 links 變數與空數列對應\nlinks = []\n# 利用 for 迴圈一一取出各網頁的 html 後, 進行解讀\n# 只取出有 videos 與 https 連結的資料, 但避開 all 與 topic 類別連結\nfor url in sources:\n    file = urlopen(url)\n    # 因為 urlopen 出來的資料為二位元檔案, 若要讀出列印\n    # 必須要先 decode() 為字串\n    #print(file.read().decode())\n    # 使用 html 解讀各連結的網頁內容\n    soup = BeautifulSoup(file, \'html.parser\')\n    # 利用 Beautifulsoup 物件中的 find_all 方法尋找 anchor\n    for link in soup.find_all(\'a\', href=True):\n        # 從各 anchor 資料篩選所需的影片連結\n        if (\'videos\' or \'https\') in link[\'href\']:\n            if \'all\' not in link[\'href\']:\n                if \'topic\' not in link[\'href\']:\n                    links.append(link[\'href\'])\n                    \n# 為避免列出重複資料, 將數列轉為集合後, 再轉回數列\nresult = list(set(links))\n# 逐一列出所取得的影片連結\nfor i in range(len(result)):\n    print(i+1, result[i]) \n 以上述程式為基礎, 從取得的影片數列, 每位學員由亂數產生的影片順序, 前後各取一個影片作為分配, 結果如下: \n 甲班 Onshape 影片分配名單: \n \n 40223109 \n https://www.onshape.com/videos/first-look-at-onshape \n https://www.onshape.com/videos/lets-make-a-part-mobile \n 40423160 \n https://www.onshape.com/videos/lets-make-an-assembly \n https://www.onshape.com/videos/lets-import-a-drawing \n 40423219 \n https://www.onshape.com/videos/lets-collaborate \n https://www.onshape.com/videos/split-face \n 40423246 \n https://www.onshape.com/videos/creating-custom-features-06-15-17 \n https://www.onshape.com/videos/getting-started-with-openbom-in-onshape \n 40523101 \n https://www.onshape.com/videos/furniture-industry \n https://www.onshape.com/videos/assembly-mates \n 40523102 \n https://www.onshape.com/videos/collaboration-simultaneous-editing \n https://www.onshape.com/videos/understanding-full-cloud-cad-and-onshape \n 40523104 \n https://www.onshape.com/videos/intro-assemblies-and-subassemblies \n https://www.onshape.com/videos/assembly-design-case-study \n 40523105 \n https://www.onshape.com/videos/working-with-existing-cad-files \n https://www.onshape.com/videos/using-mate-connectors \n 40523106 \n https://www.onshape.com/videos/essentials-multipart \n https://www.onshape.com/videos/3-ways-collaborate \n 40523107 \n https://www.onshape.com/videos/lets-make-a-part \n https://www.onshape.com/videos/assemble-an-arbor-press \n 40523108 \n https://www.onshape.com/videos/direct-editing-with-variables \n https://www.onshape.com/videos/machine-part-design-case-study \n 40523109 \n https://www.onshape.com/videos/edit-history-and-versioning \n https://www.onshape.com/videos/advanced-assembly-motion-06-22-17 \n 40523111 \n https://www.onshape.com/videos/sketching-basics-onshape \n https://www.onshape.com/videos/advanced-modeling-tools-and-workflows \n 40523112 \n https://www.onshape.com/videos/merging-branches \n https://www.onshape.com/videos/drawings \n 40523113 \n https://www.onshape.com/videos/creating-versions \n https://www.onshape.com/videos/onshape-direct-editing-04-17-15 \n 40523114 \n https://www.onshape.com/videos/lets-make-a-sprocket \n https://www.onshape.com/videos/managing-custom-properties-06-27-17 \n 40523115 \n https://www.onshape.com/videos/lets-make-a-pipe-flange \n https://www.onshape.com/videos/onshape-teams \n 40523116 \n https://www.onshape.com/videos/fillet-and-chamfer \n https://www.onshape.com/videos/essentials-documents-ui \n 40523117 \n https://www.onshape.com/videos/mixing-units-and-fractions \n https://www.onshape.com/videos/designing-fixtures \n 40523118 \n https://www.onshape.com/videos/lofting-in-onshape \n https://www.onshape.com/videos/multipart-design \n 40523119 \n https://www.onshape.com/videos/creating-weldments \n https://www.onshape.com/videos/3-examples-of-using-the-onshape-app \n 40523120 \n https://www.onshape.com/videos/lets-import-an-assembly \n https://www.onshape.com/videos/onshape-mobile \n 40523121 \n https://www.onshape.com/videos/design-in-context \n https://www.onshape.com/videos/feedback-tool \n 40523122 \n https://www.onshape.com/videos/software-overview-and-user-interface-tour \n https://www.onshape.com/videos/revolve \n 40523123 \n https://www.onshape.com/videos/lets-make-a-nut \n https://www.onshape.com/videos/using-supplier-models \n 40523124 \n https://www.onshape.com/videos/tips-and-tricks-for-the-loft-command-06-20-17 \n https://www.onshape.com/videos/import-export \n 40523125 \n https://www.onshape.com/videos/measure-tool \n https://www.onshape.com/videos/shell-and-draft \n 40523126 \n https://www.onshape.com/videos/plastic-design-and-consumer-product-case-study \n https://www.onshape.com/videos/android \n 40523127 \n https://www.onshape.com/videos/medical-device-case-study \n https://www.onshape.com/videos/assemble-gears \n 40523128 \n https://www.onshape.com/videos/lets-make-a-drawing \n https://www.onshape.com/videos/designing-linkages-in-context \n 40523129 \n https://www.onshape.com/videos/documents-and-tabs \n https://www.onshape.com/videos/lets-import-a-part \n 40523130 \n https://www.onshape.com/videos/3-examples-of-using-onshape-to-collaborate \n https://www.onshape.com/videos/parametric-modeling-and-feature-based-modeling \n 40523131 \n https://www.onshape.com/videos/essentials-assembly-basics \n https://www.onshape.com/videos/lets-make-a-frame-guide \n 40523132 \n https://www.onshape.com/videos/sketch-constraints \n https://www.onshape.com/videos/essentials-part-studios \n 40523133 \n https://www.onshape.com/videos/design-intent \n https://www.onshape.com/videos/secrets-of-the-shift-key \n 40523134 \n https://www.onshape.com/videos/direct-editing-onshape \n https://www.onshape.com/videos/onshape-cad-tutorial-creating-a-drawing \n 40523135 \n https://www.onshape.com/videos/onshape-cad-tutorial-build-your-first-assembly \n https://www.onshape.com/videos/lets-make-a-u-bolt \n 40523136 \n https://www.onshape.com/videos/basic-part-design \n https://www.onshape.com/videos/compare \n 40523137 \n https://www.onshape.com/videos/onshape-documents \n https://www.onshape.com/videos/onshape-drawings-webinar \n 40523138 \n https://www.onshape.com/videos/starting-a-design \n https://www.onshape.com/videos/essentials-onshape-mobile \n 40523139 \n https://www.onshape.com/videos/loft \n https://www.onshape.com/videos/split \n 40523140 \n https://www.onshape.com/videos/sweep \n https://www.onshape.com/videos/sheet-metal \n 40523141 \n https://www.onshape.com/videos/extrude \n https://www.onshape.com/videos/dimensions-and-constraints \n 40523142 \n https://www.onshape.com/videos/dimensions-and-constraints \n https://www.onshape.com/videos/extrude \n 40523143 \n https://www.onshape.com/videos/sheet-metal \n https://www.onshape.com/videos/sweep \n 40523144 \n https://www.onshape.com/videos/split \n https://www.onshape.com/videos/loft \n 40523145 \n https://www.onshape.com/videos/essentials-onshape-mobile \n https://www.onshape.com/videos/starting-a-design \n 40523146 \n https://www.onshape.com/videos/onshape-drawings-webinar \n https://www.onshape.com/videos/onshape-documents \n 40523147 \n https://www.onshape.com/videos/compare \n https://www.onshape.com/videos/basic-part-design \n 40523148 \n https://www.onshape.com/videos/lets-make-a-u-bolt \n https://www.onshape.com/videos/onshape-cad-tutorial-build-your-first-assembly \n \n 乙班 Onshape 影片分配名單: \n \n 40023139 \n https://www.onshape.com/videos/first-look-at-onshape \n https://www.onshape.com/videos/lets-make-a-part-mobile \n 40223208 \n https://www.onshape.com/videos/lets-make-an-assembly \n https://www.onshape.com/videos/lets-import-a-drawing \n 40371215 \n https://www.onshape.com/videos/lets-collaborate \n https://www.onshape.com/videos/split-face \n 40371235 \n https://www.onshape.com/videos/creating-custom-features-06-15-17 \n https://www.onshape.com/videos/getting-started-with-openbom-in-onshape \n 40423159 \n https://www.onshape.com/videos/furniture-industry \n https://www.onshape.com/videos/assembly-mates \n 40423204 \n https://www.onshape.com/videos/collaboration-simultaneous-editing \n https://www.onshape.com/videos/understanding-full-cloud-cad-and-onshape \n 40423207 \n https://www.onshape.com/videos/intro-assemblies-and-subassemblies \n https://www.onshape.com/videos/assembly-design-case-study \n 40423213 \n https://www.onshape.com/videos/working-with-existing-cad-files \n https://www.onshape.com/videos/using-mate-connectors \n 40423220 \n https://www.onshape.com/videos/essentials-multipart \n https://www.onshape.com/videos/3-ways-collaborate \n 40423224 \n https://www.onshape.com/videos/lets-make-a-part \n https://www.onshape.com/videos/assemble-an-arbor-press \n 40423231 \n https://www.onshape.com/videos/direct-editing-with-variables \n https://www.onshape.com/videos/machine-part-design-case-study \n 40423233 \n https://www.onshape.com/videos/edit-history-and-versioning \n https://www.onshape.com/videos/advanced-assembly-motion-06-22-17 \n 40423241 \n https://www.onshape.com/videos/sketching-basics-onshape \n https://www.onshape.com/videos/advanced-modeling-tools-and-workflows \n 40423250 \n https://www.onshape.com/videos/merging-branches \n https://www.onshape.com/videos/drawings \n 40523201 \n https://www.onshape.com/videos/creating-versions \n https://www.onshape.com/videos/onshape-direct-editing-04-17-15 \n 40523203 \n https://www.onshape.com/videos/lets-make-a-sprocket \n https://www.onshape.com/videos/managing-custom-properties-06-27-17 \n 40523204 \n https://www.onshape.com/videos/lets-make-a-pipe-flange \n https://www.onshape.com/videos/onshape-teams \n 40523205 \n https://www.onshape.com/videos/fillet-and-chamfer \n https://www.onshape.com/videos/essentials-documents-ui \n 40523206 \n https://www.onshape.com/videos/mixing-units-and-fractions \n https://www.onshape.com/videos/designing-fixtures \n 40523207 \n https://www.onshape.com/videos/lofting-in-onshape \n https://www.onshape.com/videos/multipart-design \n 40523209 \n https://www.onshape.com/videos/creating-weldments \n https://www.onshape.com/videos/3-examples-of-using-the-onshape-app \n 40523210 \n https://www.onshape.com/videos/lets-import-an-assembly \n https://www.onshape.com/videos/onshape-mobile \n 40523211 \n https://www.onshape.com/videos/design-in-context \n https://www.onshape.com/videos/feedback-tool \n 40523212 \n https://www.onshape.com/videos/software-overview-and-user-interface-tour \n https://www.onshape.com/videos/revolve \n 40523213 \n https://www.onshape.com/videos/lets-make-a-nut \n https://www.onshape.com/videos/using-supplier-models \n 40523214 \n https://www.onshape.com/videos/tips-and-tricks-for-the-loft-command-06-20-17 \n https://www.onshape.com/videos/import-export \n 40523215 \n https://www.onshape.com/videos/measure-tool \n https://www.onshape.com/videos/shell-and-draft \n 40523216 \n https://www.onshape.com/videos/plastic-design-and-consumer-product-case-study \n https://www.onshape.com/videos/android \n 40523217 \n https://www.onshape.com/videos/medical-device-case-study \n https://www.onshape.com/videos/assemble-gears \n 40523218 \n https://www.onshape.com/videos/lets-make-a-drawing \n https://www.onshape.com/videos/designing-linkages-in-context \n 40523219 \n https://www.onshape.com/videos/documents-and-tabs \n https://www.onshape.com/videos/lets-import-a-part \n 40523220 \n https://www.onshape.com/videos/3-examples-of-using-onshape-to-collaborate \n https://www.onshape.com/videos/parametric-modeling-and-feature-based-modeling \n 40523222 \n https://www.onshape.com/videos/essentials-assembly-basics \n https://www.onshape.com/videos/lets-make-a-frame-guide \n 40523224 \n https://www.onshape.com/videos/sketch-constraints \n https://www.onshape.com/videos/essentials-part-studios \n 40523226 \n https://www.onshape.com/videos/design-intent \n https://www.onshape.com/videos/secrets-of-the-shift-key \n 40523227 \n https://www.onshape.com/videos/direct-editing-onshape \n https://www.onshape.com/videos/onshape-cad-tutorial-creating-a-drawing \n 40523229 \n https://www.onshape.com/videos/onshape-cad-tutorial-build-your-first-assembly \n https://www.onshape.com/videos/lets-make-a-u-bolt \n 40523230 \n https://www.onshape.com/videos/basic-part-design \n https://www.onshape.com/videos/compare \n 40523231 \n https://www.onshape.com/videos/onshape-documents \n https://www.onshape.com/videos/onshape-drawings-webinar \n 40523232 \n https://www.onshape.com/videos/starting-a-design \n https://www.onshape.com/videos/essentials-onshape-mobile \n 40523233 \n https://www.onshape.com/videos/loft \n https://www.onshape.com/videos/split \n 40523234 \n https://www.onshape.com/videos/sweep \n https://www.onshape.com/videos/sheet-metal \n 40523236 \n https://www.onshape.com/videos/extrude \n https://www.onshape.com/videos/dimensions-and-constraints \n 40523237 \n https://www.onshape.com/videos/dimensions-and-constraints \n https://www.onshape.com/videos/extrude \n 40523238 \n https://www.onshape.com/videos/sheet-metal \n https://www.onshape.com/videos/sweep \n 40523239 \n https://www.onshape.com/videos/split \n https://www.onshape.com/videos/loft \n 40523240 \n https://www.onshape.com/videos/essentials-onshape-mobile \n https://www.onshape.com/videos/starting-a-design \n 40523241 \n https://www.onshape.com/videos/onshape-drawings-webinar \n https://www.onshape.com/videos/onshape-documents \n 40523242 \n https://www.onshape.com/videos/compare \n https://www.onshape.com/videos/basic-part-design \n 40523243 \n https://www.onshape.com/videos/lets-make-a-u-bolt \n https://www.onshape.com/videos/onshape-cad-tutorial-build-your-first-assembly \n 40523244 \n https://www.onshape.com/videos/onshape-cad-tutorial-creating-a-drawing \n https://www.onshape.com/videos/direct-editing-onshape \n 40523245 \n https://www.onshape.com/videos/secrets-of-the-shift-key \n https://www.onshape.com/videos/design-intent \n 40523246 \n https://www.onshape.com/videos/essentials-part-studios \n https://www.onshape.com/videos/sketch-constraints \n 40523248 \n https://www.onshape.com/videos/lets-make-a-frame-guide \n https://www.onshape.com/videos/essentials-assembly-basics \n 40523249 \n https://www.onshape.com/videos/parametric-modeling-and-feature-based-modeling \n https://www.onshape.com/videos/3-examples-of-using-onshape-to-collaborate \n 40523250 \n https://www.onshape.com/videos/lets-import-a-part \n https://www.onshape.com/videos/documents-and-tabs \n \n', 'tags': '', 'url': '解讀網頁內容.html'}, {'title': '輔助設計套件', 'text': "常見 MCAD 套件 \n http://lab.kmol.info/2017fall/blog/kmol-2017-fall-cadp-what-is-computer-aided-design.html \xa0 \n 一般常見的機械電腦輔助設計套件包括法國 \xa0 Dassault \xa0 公司的 \xa0 SolidWorks \xa0 與 \xa0 Catia , 美國 \xa0 AutoDesk \xa0 公司的 \xa0 AutoCAD \xa0 與 \xa0 Inventor , 德國 \xa0 Siemens \xa0 公司的 \xa0 Solid Edge \xa0 與 \xa0 NX , 美國 \xa0 PTC \xa0 公司的 \xa0 Creo , 以及 2015 年推出的 \xa0 Onshape \n 其他 MCAD: 俄羅斯的 \xa0 T-Flex , 美國的  Hyperworks \xa0 \n 免費學生 MCAD/E 套件 \n Onshape 免費教育版 ,  Onshape 教育課程 \n AutoDesk 免費教育版  (包括  Inventor \xa0,\xa0 AutoCAD \xa0與  Fusion 360 ) \n PTC Creo student 免費版本 \n Solid Edge student 免費版本 \n free Hyperworks student edition \n Abaqus 免費學生版 \n Ansys 免費學生版 \n Simscale 免費社群帳號 \n 參考資料 \n 從電腦輔助系統發展至使用者從旁導引, 一直到電腦系統自主控制... \n CAD History.pdf \n CAD Book.pdf \n Intro_computer_aided_design.pdf \n intro_design.pdf \n CADCAECAM_Review.pdf \n Computer Aided Design and Manufacturing.pdf  by  Bowyer \n Introduction_Computing_Geometry.pdf \n A Geometric Interface for Solid Modelling.pdf \xa0( Intro to Djinn ) \n Solid Modeling Basics.pdf \n Solid Modeling.pdf \n Geometric_Modeling_ch1.pdf \n Geometric_Modeling_ch2.pdf \n Geometric_Modeling_ch3.pdf \n Geometric_Modeling_ch4.pdf \n Geometric_Modeling_ch5.pdf \n Geometric_Modeling_ch6-1.pdf \n Geometric_Modeling_ch6-2.pdf \n Geometric_Modeling_ch7.pdf \n Geometric_Modeling_engr_applicatio n.pdf \n SvLis.7z \xa0( https://github.com/AdrianBowyer/SvLis ) \n Learn Autodesk Inventor 2018 Basics \n https://link.springer.com/book/10.1007/978-1-4842-3225-5 \xa0 \n 2016 Solid Modeling and Applications - Rapid Prototyping, CAD and CAE Theory \n https://link.springer.com/book/10.1007/978-3-319-21822-9 \xa0 \n 2016 Computer Aided Virtual Manufacturing using Creo Parametric \n https://link.springer.com/book/10.1007/978-3-319-23359-8 \xa0 \n 2015 Space Modeling with Solidworks and NX \n https://link.springer.com/book/10.1007/978-3-319-03862-9 \xa0 \n Modelica \n https://www.modelica.org/ \xa0 \n https://openmodelica.org/ \xa0 \n https://github.com/OpenModelica/OpenModelica \xa0 \n Introduction to object oriented modeling\xa0 with modelica.pdf \n https://github.com/dzimmer/PlanarMechanics \xa0 \n Logical Foundations of Cyber Physical Systems.pdf \n Highly Automated Vehicle System.pdf \n 如何進行電腦輔助機械設計專題 \n 1. 文獻回顧 (Literature Review) 階段 - 了解現存既有的研究成果, 確立專題定位與目標 \n 利用關鍵字搜尋相關文獻, 針對文獻回顧與探討, 初步定位專案性質以及從事專案的目標. \n 例如, 關鍵字: \xa0 marble machine construction set , \xa0 linkage synthesis , \xa0 arduino mechatronics , \xa0 arduino servo control , \xa0 lifter linkage , \xa0 Doing a Literature Review \n 2. 整理可用工具, 擬想何謂機械?何謂設計?何謂電腦輔助?擬想所要解決的問題, 準備開始進行電腦輔助機械設計專題 \n 機械是一種功能明確的器物, 內容包含固體、流體與軟體元件, 彼此精巧配置結合, 可展現特定功能 \n 設計是一種表達, 而且是可以讓人依循, 逐步按照指示, 完成設計者預想的結果, 且表達方法包含文字、口語、2D、3D、數學與實體方法. \n 文字結合 2D、3D、數學表達方法 - 設計專題報告 \n 利用口語簡報設計專題內容 - 設計專題報告影片 \n 電腦輔助 - 利用電腦的功能協助設計進行 \n 電腦功能 - 設計組態管理、運算、模擬、網路資訊傳輸、展示、協同 \n 例如: \n 零組件繪圖工具: \xa0 Solvespace \xa0 (包含在隨身系統), \xa0 Onshape \xa0 (自行申請帳號), \xa0 PTC Creo Parametric \xa0 (可從區網下載可攜網路認證版本) , \xa0 Autodesk Inventor \xa0 (可自行申請免費學生版本或安裝系上提供之網路認證版本), \xa0 Dassault Solidworks \xa0 (可安裝學校提供之網路認證版本). \n 協同工具: \xa0 Onshape \xa0 (自行申請帳號), \xa0 A360 \xa0 (自行申請帳號) \n 模擬工具: \xa0 V-rep \xa0 (包含在隨身系統), \xa0 Blender \xa0 (包含在隨身系統), \xa0 Tinkercad \xa0 (自行申請帳號) \n 控制與致動工具: \xa0 Arduino \xa0 (包含在工具箱中), \xa0 Servo Motor \xa0 (包含在工具箱中) \n 3D 列印工具: \xa0 Delta Printer \xa0 (由系上實習設備提供) \n 3. 根據專題定位與目標, 確定所要解決的問題項目, 逐一採模組式, 以協同流程, 透過自學、執行與檢討想像, 由簡入繁, 持續改進各模組的內容與功能, 在可用時間內, 解決各種問題, 終至完成專題, 達成目標. \n 鋼球循環運動系統設計 \n 機構設計 - 軌道設計、鋼球提升與傳動系統設計、其他零組件設計 \n 致動與控制系統設計 - 電路設計、伺服馬達致動程式設計 \n 監控程式設計 - 以視窗程式啟動系統運作、傳回鋼球通過控制點訊息、計算運行距離與速度 \n marble lift mechanism \n 四連桿浮動桿通過三個位置的尺寸合成設計 \n 六連桿尺寸合成 \n 八連桿尺寸合成 \n http://www.eddiesmind.com/basic-lifting-mechanisms.html \n Linkage: \xa0 http://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/ \xa0 ( Source codes ) \n LinkageDesigner (an add-on package to Wolfram's Mathematica): \xa0 http://www.linkagedesigner.com/ , \xa0 https://www.wolfram.com/products/applications/linkagedesigner/ \n https://github.com/KmolYuan/Pyslvs-PyQt5", 'tags': '', 'url': '輔助設計套件.html'}, {'title': 'Creo', 'text': "The most import feature in Creo 4.0 \n What's new in Creo 5.0 \n Primer_Creo_2.pdf \n Creo_Parametric_v2_Advanced_Primer.pdf \n Creo_Parametric_v2_Sheet_Metal.pdf \n Creo_Parametric_v2_Mechanism_Design.pdf \n Creo_Parametric_v3_Helical_Sweeps.pdf \n Creo_Parametric_v2_ISDX.pdf \n Creo_Parametric_v2_Pillow_Block.pdf \n Creo_Parametric_v2_Chain_Drive.pdf \n Creo_Parametric_v2_Oil_Cover.pdf \n Creo_Parametric_v2_Sensitivity_Feasibility.pdf \n Creo_Parametric_v2_Minimize_Volume.pdf \n 參考資料 \n http://engr.bd.psu.edu/METBD_306_m/METBD_306_m/main_306.html  (使用 Excel 與 MathCAD 輔助設計運算) \n \n", 'tags': '', 'url': 'Creo.html'}, {'title': 'Kinematics', 'text': '2013\xa0 21st Century Kinematics: \n https://link.springer.com/book/10.1007/978-1-4471-4510-3 \xa0 \n', 'tags': '', 'url': 'Kinematics.html'}, {'title': 'Dynamics', 'text': '2003 Rigid Body Dynamics of Mechanism \n https://link.springer.com/book/10.1007/978-3-662-09769-4 \xa0 \n \n', 'tags': '', 'url': 'Dynamics.html'}, {'title': 'PythonCAD', 'text': "R37 使用 PyGTK \n R38 使用 PyQt \n http://download2.polytechnic.edu.na/pub4/sourceforge/p/project/py/pythoncad/ \xa0 \n 以下版本使用 Python3 與 PyQt5: \n https://github.com/chiamingyen/PythonCAD_py3 \xa0 \n 以下資料為 R37 對應版本參考用: \n This introduces you into the basic concepts of a CAD system. \n Entities \n Entities are graphical objects in a CAD system. Typical entities which are supported by most CAD systems are: points, lines and circular and elliptical arcs. More complex and CAD specific entities include polylines, texts, dimensioning, hatches and splines. Attributes \n Every entity has certain attributes such as its color, line type and line width. \n Layers \n A basic concept of computer aided drafting is the use of layers to organize a drawing. Every entity of a drawing is on exactly one layer and a layer can contain lots of entities. Typically entities with a common 'function' or common attributes are put on the same layer. E.g. you might want to put all axes in a drawing on a layer named 'axes' (see Figure 1). Layers can have attributes (color, line width, line style). Each entity can have its own attributes or have its attributes defined by the layer it is placed on. In the latter case you can change for example the color of all 'axes' entities by changing the color of the layer 'axes'. \n In manual drafting, a similar approach was used. Different building systems, such as wiring and air conditioning were often drawn on separate transparent sheet of paper. These sheets were then overlaid on one another to produce final drawings. \n Blocks \n A Block is a group of entities. Blocks can be inserted into the same graphic more than once with different Attributes and different locations, scaling factors and rotation angles (see Figure 2). Such an instance of a block is usually called an Insert. Inserts have attributes just like entities and layers. An Entity that is part of an Insert can have its own attributes or share the attributes of the Insert. Once created, Inserts are still linked to the Block they instantiate. The power of inserts is, that you can modify the Block once and all Inserts will be updated accordingly. \n Drafting in CAD \n In many ways, CAD is similar to traditional drafting. When drawing a plan or a view of an object on a paper, you would use tools such as a ruler to draw lines. In CAD systems there is a variety of tools available to achieve the same goal. The big advantage of a CAD system is the fact that you can change every entity of your drawing easily after you've created it. This might be the most difficult thing to learn when moving from paper to CAD. When working with a CAD system you will very often create lines that won't be on the final printout or which don't have the correct length and need to be trimmed later (see Figure 3). A common mistake of CAD beginners is wanting to create the final drawing right away. \n Coordinate Systems \n A good understanding of how coordinates work is absolutely crucial if you are to make the best use of any CAD program. If you're not familiar with coordinates it's highly recommended that you take some time to familiarize yourself with the basic concepts. \n Origin \n The origin of the drawing is the point where the X and Y axis cross each other. It's the absolute zero of the drawing. In addition to the origin there's a relative zero point. This is a helpful spot that changes it's position depending on the current user interactions. The relative zero point can also be moved around by the user. \n Cartesian Coordinates \n The Cartesian coordinate system is the standard coordinate system. It was named after the French philosopher René Descartes (1596-1650). The position of a point is described by its distance from two axes, X and Y. It is commonly denoted by x, y where x and y are the distances. Positive X direction is left while positive y direction is up. \n Cartesian coordinates can also originate in a position different from the origin. In that case we talk about 'relative coordinates'. \n Polar Coordinates \n Polar coordinates use a distance and an angle to describe the position of a point. \n Just like Cartesian coordinates, polar coordinates can also originate in a position different from the origin. \n Object and Grid Snapping \n To specify a coordinate, you can use the snap feature which allows you to precisely select grid points or significant points on existing objects: endpoints or midpoints of lines, etc. \n Basic Editing \n Entities can be inserted, selected, and, once selected, can be deleted, transformed or duplicated. To insert an entity means to draw it by selecting the appropriate drawing tool, such as line, arc, etc., and by locating points that define the object to be drawn, such as the endpoints of a line. \n Entity Selection \n An entity must be selected before it can be deleted, duplicated, or transformed. Entity selection is one of the most basic of CAD operations. There are a wide variety of selection tools to quickly select groups of entities, entities within a range, connected entities, etc. \n Deletion \n Deleting an entity means to remove it from the drawing. \n Modifications \n Basic modifications of a CAD systems include translation, rotation, reflection, and scaling. As well as these operations which don't alter the characteristic geometry of selected entities, there are some that do. You can break, trim, extend or stretch existing entities. \n Dimensions \n The required sizes of features are conveyed through use of dimensions. Distances may be indicated with either of two standardized forms of dimension: linear and ordinate. \n With linear dimensions, two parallel lines, called “extension lines,” spaced at the distance between two features, are shown at each of the features. A line perpendicular to the extension lines, called a “dimension line,” with arrows at its endpoints, is shown between, and terminating at, the extension lines. The distance is indicated numerically at the midpoint of the dimension line, either adjacent to it, or in a gap provided for it.   With ordinate dimensions, one horizontal and one vertical extension line establish an origin for the entire view. The origin is identified with zeroes placed at the ends of these extension lines. Distances along the x- and y-axes to other features are specified using other extension lines, with the distances indicated numerically at their ends.   Sizes of circular features are indicated using either diametral or radial dimensions. Radial dimensions use an “R” followed by the value for the radius; Diametral dimensions use a circle with forward-leaning diagonal line through it, called the diameter symbol, followed by the value for the diameter. \n A radially-aligned line with arrowhead pointing to the circular feature, called a leader, is used in conjunction with both diametral and radial dimensions. All types of dimensions are typically composed of two parts: the nominal value, which is the “ideal” size of the feature, and the tolerance, which specifies the amount that the value may vary above and below the nominal. Architectural Dimensions \n Viewing in CAD \n Unlike in manual drafting, there is no need in CAD to determine in advance the sheet size and drawing scale. There is no drawing scale: all sizes and distances are specified using their full-scale values. A 10 meter object is drawn as a 10 meter object. Only at the printing stage, the drawing scale needs to be determined based on sheet size and drawing size. \n On the screen, the user can adjust the currently visible area of the drawing by zooming in to view more detail or zooming out to view a wider extent. Another important viewing operation in CAD is panning. To see another portion of the drawing without changing the display scale, a user pans to it by “moving” a rectangular display window until it's over the desired spot. \n From R38 version the command are changed this new list describe how to use it and what they do \n \n \n SEGMENT \n \n \n ARC \n \n \n CIRCLE \n \n \n POINT \n \n \n ELLIPSE \n \n \n POLYLINE \n \n \n CLINE \n \n \n CCIRCLE \n \n \n TEXT \n \n \n CHAMFER \n \n \n FILLET \n \n \n BISECTOR \n \n \n RECTANGLE \n \n \n POLYGON \n \n \n COPY \n \n \n MOVE \n \n \n MIRROR \n \n \n ROTATE \n \n \n TRIM \n \n \n DELETE \n \n \n DIMENSION \n \n \n PROPERTY \n \n \n Command \n Command Line Staff Only R38 \n \n If the CAD is waiting for a point you can use the following form to input the point from a command line: \n \n \n absolute coords 10,10 \n \n \n relative coords 10;10 \n \n \n relative coords angle>lenght \n \n \n Unit Mesure: PythonCAD use the mm radiants as input value .. if you whant to input a different unit measure you can use the sympy syntax as follow. the unit measure converter is retrieved by using the u letter .. es: \n \n \n 10*u.ft → translate 10 ft in mm \n \n \n 10,10*u.ft \n \n \n 45*u.deg>100 \n \n \n File \n \n \n It opens drop down menu for the \xa0 file \xa0 manipulation. The menu consists of \n \n \n New \n \n \n Open \n \n \n Import \n \n \n Close \n \n \n Save <R38 \n \n \n Save as … \n \n \n Save layer as … \n \n \n Print screen \n \n \n Print \n \n \n Quit \n \n \n \n Edit \n \n \n \n Undo \n \n \n Redo \n \n \n Cut \n \n \n Copy \n \n \n Paste \n \n \n Select \n \n \n Select all \n \n \n Deselect \n \n \n Preferences \n \n \n Draw \n \n \n \n \n Basic \n \n \n Point \n \n \n Segment \n \n \n Rectangle \n \n \n Circle \xa0 center and radius \n \n \n Circle (2pts) \xa0 diameter points \n \n \n Arc \n \n \n \n \n Con. lines (construction lines) \n \n \n Horizontal \n \n \n Vertical \n \n \n Angled \n \n \n Two points \n \n \n Perpendicular \n \n \n Parallel \n \n \n Tangent \n \n \n Tangent 2 circ \n \n \n \n \n Con. circs. (construction circles) \n \n \n Center pt. \n \n \n Two pts. \n \n \n Single tangency \n \n \n Dual tangency \n \n \n \n \n Chamfer \n \n \n Fillets \n \n \n point \n \n \n twoline \n \n \n \n \n Leader \n \n \n Polyline \n \n \n Polygon (int.) \n \n \n Polygon (ext.) \n \n \n Text \n \n \n Set \n \n \n Colors \n \n \n Sizes \n \n \n Style \n \n \n TextStyle \n \n \n DimStyle \n \n \n Display \n \n \n Units \n \n \n \n \n Add new \n \n \n Style \n \n \n Line type \n \n \n \n \n Modify \n \n \n \n \n Move - alter the position of entities \n \n \n Stretch - alter the size of entities \n \n \n Split - create additional vertices in entities \n \n \n Mirror - \n \n \n Transfer - move entities to another layer \n \n \n Rotate - rotate entities to an angle around a point \n \n \n Delete \n \n \n Change \n \n \n Trim >= R38 \n \n \n View \n \n \n \n \n Zoom window - draw a rectangle to designate the area to be displayed \n \n \n Zoom in \n \n \n Zoom out \n \n \n Zoom Pan - Pan the Drawing \n \n \n Zoom fit - show the drawing at a size that will include all entities \n \n \n Snap \n \n \n \n \n Mid Point - Snap the Media Point of a segment \n \n \n Point - Snap On a Point \n \n \n Center - Snap On the Center of arc circle \n \n \n End Point - Snap The end point of a segment \n \n \n Intersection Point -Snap on the intersection point \n \n \n Origin Point - Snap on the Drawing origin point 0,0 \n \n \n Perpendicular - Snap on perpendicular \n \n \n Tangent - Snap on Tangent \n \n \n Dimensions \n \n \n \n \n Linear \n \n \n Horizontal \n \n \n Vertical \n \n \n Radial \n \n \n Angular \n \n \n Debug \n \n \n \n \n Focus \n \n \n Undo stack \n \n \n Redo stack \n \n \n Image undo \n \n \n Image redo \n \n \n GC \n \n \n Code Organization \n An overall goal is to keep the front-end interface code as separate from the back-end code as can be achieved. Using a high level language like Python helps immensely in moving towards this goal, as Python provides basic data structures like lists, tuples, and directories (hashes) as built-in components of the language. There is no need to hand-roll these data structures so that all the code, both generic and interface specific, could make use of these essential building blocks of a program. As both the interface and back-end code have these structures available by the nature of the language, the task of keeping the interface code and generic code separated is much simpler. \n All code that comprises the core objects in the program, and anything else that is interface neutral, is kept in the Generic subdirectory. The interface code is kept in an Interface directory, and the code for a specific interface is kept in a subdirectory below that. The initial release has a Gtk subdirectory, and it is hoped that there will be several companion subdirectories eventually. \n Generic Directory \n There are presently no subdirectories in this directory. It is in this directory that the code for things like points, segments, layers, etc., is located. Also, there is code in here for things such as calculating intersections of the objects, compressed file reading and writing, saving and loading of files, and various utility functions. There will probably be several subdirectories in here at some point, and files performing certain functions will be moved as needed, but these changes will depend on how the program evolves. All code that finds its way into this directory should never rely on any Python modules outside of the standard set of Python modules. \n Interface Directory \n Here is where the Gtk subdirectory sits, and in that directory is all the code for presenting the user interface. It is this code that relies on the PyGTK module. So far that module is the only third party module needed for running PythonCAD. \n As more interfaces are added, their code should then be placed in this directory. All code in the Interface directory uses code in the Generic directory to whatever extent is needed. If a particular interface is requiring some specific functionality in the drawing entities, rather than code being added in this directory that performs the function, that functionality should be considered being moved to the entity itself so that other interfaces may also benefit. By enriching the basic functionality of the core objects, the interface code can be kept to a minimum, and interface-specific object functionality will be reduced. This should hopefully produce a more robust core code-base. \n Features \n \n Draw points, lines, rectangles, circles, arcs, polygons, text \n Draw fillets and chamfers \n Draw dimensions \n Styles: Linetype (solid, dashed), color, thickness \n Move \n Stretch \n Rotate \n Split \n Layers \n Open, Save in XML format, and Print drawings \n Undo \n Zoom in, out, window, fit, Dynamic pan and zooming \n Select All by object type \n Set preferences for Units, colors, line thickness, Object sizes, text and dimensions \n Draw with the following units: micrometers, millimeters, Meters, Kilometers, Inches, Feet, Yards, Miles \n Command line for entering commands \n Dynamic snap \n \n File format 參考:\xa0 http://pythoncad.sourceforge.net/dokuwiki/doku.php?id=file_format_reference \xa0 \n \n", 'tags': '', 'url': 'PythonCAD.html'}, {'title': 'WaferRobot', 'text': 'Infineon Technology Austria \n \n TSMC \n \n \n \n WaferPro Software \n \n Silicon Wafer Production \n \n \n Wafer Handling \n \n Wafer Mover \n \n \n Wafer Sorter \n \n \n \n Wafer Prober \n \n 參考資料: \n http://trc2018.cn.nctu.edu.tw/ \xa0 \n trc2018_info.pdf \n trc2018 Q&A.pdf \n trc2018_proposal_sample.pdf \n 任務一:晶圓傳送\xa0 (Cassette-Chamber-Cassette) \n 由 Cassette A 取出一片晶圓依序傳送至六個腔體 (Chamber A~F), 短暫停留指定時間, 最後傳回 Cassette B. \n \n 任務二:晶圓排序\xa0 (Wafer Sequence) \n 參賽者向平台詢問 Cassette A\xa0 的 slotmap, 根據 slotmap 向平台詢問晶圓編號, 依編號由 Cassette A 取出晶圓後傳送至 Cassette B 對應 Slot. \n \n 任務三:晶圓製程 \n 最佳排程 \n 參賽者根據競賽平台指定之 6 片晶圓製程, 設計排程將每片晶圓取放至對應 Chamber,\xa0依序完成每道製程內容, 競賽平台依完成全部製程之總時間給予評分. \n \n 精準取放 \n 參賽者將晶圓放入 Chamber A, 競賽平台以 CCD 相機偵測晶圓取放位置, 根據其精準度給予評分. \n \n 製程判斷 \n Chamber B, D, E, F為製程站點, 參賽者放置好晶圓後, 須下 Chamber Start 指令給競賽平台, 並蒐集競賽平台提供之製程資料, 根據資料曲線判斷製程是否完成或有異常發生, 競賽平台根據參賽者製程判斷之準確性給予評分. \n \n 平穩傳送 \n 參賽者將晶圓放入 Chamber C, 競賽平台以 Dot Laser 偵測晶圓傳送過程之角度平均\xa0 𝜃\xa0̅ 與標準差\xa0 𝜎\xa0 給予評分. \n \n 瑕疵檢測 \n Chamber C 為檢測站點, 參賽者放置好晶圓後, 須下 Chamber Start 指令給競賽平台, 並根據競賽平台提供之影像編號, 針對特定影像做瑕疵檢測, 競賽平台根據參賽者檢測結果之準確性給予評分. \n 得分 = 100*(正確數量 - 誤判數量) /實際數量 \n \n 任務平台 \n \n 任務平台尺寸 \n \n 任務平台 STEP 格式壓縮檔 \xa0(rar) \n 任務平台尺寸 DWG 格式壓縮檔案  (7z) \n 3D 任務平台\xa0 in Onshape \n Chamber Pin 尺寸圖 \n \n \n \xa0 \n Cassette 尺寸 \n \n Wafer 尺寸 \n \n \n \n Spec. \n 8吋晶圓 \n \n \n Diameter \n 200+/-.2mm \n \n \n Thickness \n 700um~1000um \n \n \n', 'tags': '', 'url': 'WaferRobot.html'}, {'title': 'Evaluation', 'text': '1.計畫書審查 \n 依構想計畫書進行評比, 針對其中的執行步驟、硬體設計以及設計特色進行給分, 評比標準如下. \n \n \n \n 評比項目 \n 項目說明 \n 配分 \n \n \n 硬體及控制系統設計構想 \n 機器手臂系統完整程度，包含 原形機構設計、機電控制 \n 35% \n \n \n 演算法初步構想 \n 針對各個任務所開發之演算法構想 \n 35% \n \n \n 獨特性 \n 機械手臂設計的原創性 \n 30% \n \n \n \n 2.規劃簡報 \n 依各組之簡報和目前手臂運作影片進行評比, 將對於其手臂完程度以及報告完整性作評分, 評比標準如下. \n \n \n \n 評比項目 \n 項目說明 \n 配分 \n \n \n 簡報完整性 \n 製作進度內容及表達完整性 \n 30% \n \n \n 影片審查 \n 機器人軟硬體實現程度 \n 40% \n \n \n 獨特性 \n 作品中的原創性 \n 30% \n \n \n \n 3.專案評比 \n 依各組專案執行之書面報告審查進行評比,\xa0評比標準如下. \n \n \n \n 評比項目 \n 項目說明 \n 配分 \n \n \n 性能評比 \n Cycle Time、重複精度、定位精度、穩定度 \n 30% \n \n \n 排程運作 \n 操作時間、操作完成度、機器人教導便利性 \n 30% \n \n \n 檢測結果 \n 辨識準確率、辨識效率 \n 30% \n \n \n 創意加分 \n 創意思維、可延伸性 \n 10% \n \n \n \n \n', 'tags': '', 'url': 'Evaluation.html'}, {'title': '分組專題', 'text': '分組專題報告 \n 章節 \n \n 標題頁 - 含報告標題、作者、日期與所屬單位 \n 目錄 - 列出全文章節與所屬頁面連結 \n 摘要 - 解釋報告編寫動機、報告重點、結論、建議與關鍵字 \n 前言 - 簡要描述全文意旨與背景, 說明報告目標與報告內容組成架構 \n 內文 - 依照章節標題, 詳細說明報告內容, 包括方法、操作步驟與所得結果的詳細說明 \n 結論 - 條列所獲致的重要成果, 與摘要及導言中的目標互相呼應 \n 討論與建議 - 說明後續值得進行的方向、方法與可能遭遇問題的討論 \n 參考 - 詳列所引用的參考內容 \n 附錄 - 附加值得參考的詳細內容 \n \n cadp_project_ex1.pdf \n 設計一個實用的網際 peer evaluation site: \n peer_evaluation_form.pdf', 'tags': '', 'url': '分組專題.html'}, {'title': '3D 列印機', 'text': '分組專題人員: 六人 \n 設計模擬: 三人 \n 組立製作: 三人 \n XYZ 架構 \n https://github.com/mdecourse/kll3pp \xa0 \n Onshape 零組件 \n \n \n Delta 架構 \n 分組專題人員: 六人 \n Delta 3D 印表機  ( Onshape  連結) \n \n 參考資料 \n https://reprap.org/wiki/RepRap \xa0 \n RepRap - The Replicating Rapid Prototyper.pdf \n Advances in 3D Printing & Additive Manufacturing Technologies \n https://link.springer.com/book/10.1007/978-981-10-0812-2 \xa0 \n \n', 'tags': '', 'url': '3D 列印機.html'}, {'title': '行走機構', 'text': '主動式行走機構 - Active Walker - 以馬達驅動行走 \n 分組專題人員: 六人 \n 設計模擬: 三人 \n 組立製作: 三人 \n Jansen_walker  in  Onshape \n \n 被動式行走機構 - Passive Walker - 以重力在斜坡或移動平台上行走 \n 分組專題人員: 六人\xa0 \n Onshape  設計,  V-rep  模擬 \n Passive dynamic walking \n Passive dynamics \n Biped walking robot control with passive walker model by new VSC servo \n Passive dynamic walker \n Passive walking \n Actuating a Simple 3D Passive Dynamic Walker \n The Simplest Walking Model: Stability, Complexity, and Scaling \n https://github.com/kenaycock/Six-Bar-Walking-Mechanism \xa0 \n 專題目的:  創新步行輔助機構之設計與應用 \n', 'tags': '', 'url': '行走機構.html'}, {'title': '鋼球運動系統', 'text': '分組專題人員: 六人 \n 設計模擬: 三人 \n 組立製作: 三人 \n \n', 'tags': '', 'url': '鋼球運動系統.html'}, {'title': '機械手臂', 'text': 'https://github.com/mdecourse/EvoArm \xa0 \n \n \n \n \n 參考資料 \n https://www.eng.yale.edu/grablab/openhand/ \xa0 \n https://github.com/grablab/openhand-hardware \n https://github.com/grablab/openhand-software \n https://github.com/grablab/Yale-OpenHand-Workshop-2018 \xa0 \n', 'tags': '', 'url': '機械手臂.html'}, {'title': '虛實手足球', 'text': '分組專題人員: 六人 \n 設計模擬: 三人 \n 組立製作: 三人 \n Table Football Machine \n \n 利用  Onshape  或  Solvespace  設計所需零組件 \n 將模型輸入 V-rep 後, 以 Lua 控制各零組件運動, 進行初步測試 \n 利用 Python 程式, 透過網路, 由競賽雙方以 Rempte API 型式, 操控足球員動作 \n 虛擬系統完成後, 設計外部實體電子控制系統, 操控虛擬足球員, 或反向運作 \n \n \n 利用彈珠檯的旋轉擊球機制, 加上擊球桿的平移, 可以製作 V-rep 模型中的手足球員. \n \n https://github.com/kmolab/pymcadp/blob/gh-pages/data/v-rep/pinball2/pinball4_rotational.ttt \xa0 \n', 'tags': '', 'url': '虛實手足球.html'}, {'title': '機械計時器', 'text': '分組專題人員: 六人 \n 設計模擬: 三人 \n 列印製作: 三人 \n \n', 'tags': '', 'url': '機械計時器.html'}, {'title': '摺疊自行車', 'text': '1/18 Scale folding bike 摺疊自行車模型設計製作 \n 分組專題人員: 六人 \n \n 參考資料: \n http://rattlecad.sourceforge.net/ \xa0 \n', 'tags': '', 'url': '摺疊自行車.html'}, {'title': '方程式賽車', 'text': '1/18 Scale Forumla Student Racing Car \n 分組專題人員: 六人 \n Forumla Student Rules 2018 \n \n 參考資料: \n https://uwformula.com/ \xa0 \n http://learnmech.com/ \xa0 \n https://github.com/Caesor/racing-game \xa0 \n https://www.kingautos.net/212575 \xa0 \n https://news.tvbs.com.tw/fun/670993 \xa0 \n http://www.pme.nthu.edu.tw/files/14-1265-124394,r4641-1.php?Lang=zh-tw \xa0 \n https://insight.udndata.com/ndapp/udntag/finance/Article?origid=9058520 \xa0', 'tags': '', 'url': '方程式賽車.html'}]};